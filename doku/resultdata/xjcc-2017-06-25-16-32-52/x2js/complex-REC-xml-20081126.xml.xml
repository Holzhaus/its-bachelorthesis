<spec w3c-doctype="rec" xml:lang="en"><back><div1 id="sec-bibliography"><div2 id="sec-existing-stds"><blist><bibl href="http://www.iana.org/assignments/character-sets" id="IANA" key="IANA-CHARSETS"><titleref>Official Names for Character Sets</titleref>(Internet
Assigned Numbers Authority) 
,
ed. Keld Simonsen et al.</bibl><bibl href="http://www.ietf.org/rfc/rfc2119.txt" id="rfc2119" key="IETF RFC 2119"><titleref>RFC 2119: Key words for use in RFCs to Indicate Requirement Levels</titleref>IETF
(Internet Engineering Task Force). 
.
Scott Bradner, 1997.</bibl><bibl diff="chg" id="RFC1766" key="IETF BCP 47"><loc href="E01" role="erratumref" /><titleref><loc href="http://tools.ietf.org/html/rfc4646">RFC 4646: Tags for Identifying Languages</loc><loc href="http://tools.ietf.org/html/rfc4647">RFC 4647: Matching of Language Tags</loc>BCP 47, consisting of 
, and </titleref>IETF
                                          (Internet Engineering Task Force). 
,
						A. Phillips, M. Davis. 2006.</bibl><bibl href="http://www.ietf.org/rfc/rfc3986.txt" id="rfc3986" key="IETF RFC 3986"><titleref>RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</titleref>IETF (Internet Engineering Task Force). 
. T. Berners-Lee, R. Fielding, L. Masinter. 2005.</bibl><bibl id="ISO10646" key="ISO/IEC 10646"><loc href="http://www.iso.org/iso/home.htm">http://www.iso.org/iso/home.htm</loc><titleref>ISO/IEC 10646-1:2000. Information
technology — Universal Multiple-Octet Coded Character Set (UCS) —
Part 1: Architecture and Basic Multilingual Plane</titleref><titleref>ISO/IEC 10646-2:2001.
Information technology — Universal Multiple-Octet Coded Character Set (UCS) — Part 2:
Supplementary Planes</titleref>ISO (International
Organization for Standardization). 
 and 
, as, from time to time, amended, replaced by a new edition or
expanded by the addition of new parts. [Geneva]: International Organization for Standardization.
(See 
 for the latest version.)</bibl><bibl id="ISO10646-2000" key="ISO/IEC 10646:2000"><titleref>ISO/IEC 10646-1:2000. Information
technology — Universal Multiple-Octet Coded Character Set (UCS) —
Part 1: Architecture and Basic Multilingual Plane.</titleref>ISO (International
Organization for Standardization). 
 [Geneva]: International
Organization for Standardization, 2000.</bibl><bibl id="Unicode" key="Unicode"><emph><phrase diff="chg"><loc href="E11" role="erratumref" />5.0.0,</phrase>The Unicode
Standard, Version </emph><phrase diff="del"><loc href="E11" role="erratumref" />Reading, Mass.: Addison-Wesley Developers Press,
1996</phrase><phrase diff="add"><loc href="E11" role="erratumref" />defined by: The Unicode Standard, Version 5.0 (Boston, MA,
Addison-Wesley, 2007. ISBN 0-321-48091-0)</phrase>The Unicode Consortium. 
 
.</bibl><bibl href="http://unicode.org/reports/tr15/" id="unipart15" key="UnicodeNormal"><titleref>Unicode normalization forms</titleref>The Unicode
Consortium. 
.  Mark Davis and
Martin Durst.  2008.</bibl><bibl diff="del" id="Unicode3" key="Unicode3"><emph>The Unicode Standard, Version 3.2</emph><emph>The Unicode Standard, Version 3.0</emph><emph>Unicode
Standard Annex #27: Unicode 3.1</emph><emph>Unicode Standard Annex #28: Unicode
3.2</emph><loc href="E11" role="erratumref" /><loc href="http://www.unicode.org/reports/tr27/">http://www.unicode.org/reports/tr27</loc><loc href="http://www.unicode.org/reports/tr28/">http://www.unicode.org/reports/tr28</loc>The Unicode
Consortium. 
, defined by:

 (Reading, MA,
Addison-Wesley, 2000. ISBN 0-201-61633-5), as amended by the 

(
) and the 

(
).</bibl>
					

					

					

					

					

					

					

	  

					

				</blist><head>Normative References</head>
				

				

			</div2><div2 id="null"><blist><bibl id="Aho" key="Aho/Ullman"><titleref>Compilers: Principles, Techniques, and Tools</titleref>Aho, Alfred V., Ravi Sethi, and Jeffrey D.
Ullman. 
.
Reading: Addison-Wesley, 1986, rpt. corr. 1988.</bibl><bibl href="ftp://ftp.informatik.uni-freiburg.de/documents/papers/brueggem/habil.ps" id="ABK" key="Brüggemann-Klein"><titleref>Formal Models in Document Processing</titleref>Brüggemann-Klein,
Anne. 
. Habilitationsschrift. Faculty
of Mathematics at the University of Freiburg, 1993.</bibl><bibl id="ABKDW" key="Brüggemann-Klein and Wood"><titleref>Deterministic Regular Languages</titleref><titleref>One-Unambiguous
Regular Languages</titleref>Brüggemann-Klein,
Anne, and Derick Wood. 
.
Universität Freiburg, Institut für Informatik, Bericht 38, Oktober 1991. Extended
abstract in A. Finkel, M. Jantzen, Hrsg., STACS 1992, S. 173-184. Springer-Verlag,
Berlin 1992. Lecture Notes in Computer Science 577. Full version titled 
 in Information and Computation 140 (2): 229-253,
February 1998.</bibl><bibl href="http://www.w3.org/TR/NOTE-sgml-xml-971215" id="Clark" key="Clark"><titleref>Comparison of SGML and XML</titleref>James Clark.

.</bibl><bibl diff="chg" href="http://www.iana.org/assignments/language-subtag-registry" id="IANA-LANGCODES" key="IANA-LANGCODES"><loc href="E01" role="erratumref" /><titleref>Registry of Language Tags</titleref>(Internet
Assigned Numbers Authority) </bibl><bibl href="http://www.ietf.org/rfc/rfc2141.txt" id="RFC2141" key="IETF RFC 2141"><titleref>RFC 2141: URN Syntax</titleref>IETF
(Internet Engineering Task Force). 
, ed.
R. Moats. 1997. </bibl><bibl href="http://www.ietf.org/rfc/rfc3023.txt" id="rfc2376" key="IETF RFC 3023"><titleref>RFC 3023: XML Media Types</titleref>IETF
(Internet Engineering Task Force). 
.
eds. M. Murata, S. St.Laurent, D. Kohn. 2001.</bibl><bibl href="http://www.ietf.org/rfc/rfc2781.txt" id="rfc2781" key="IETF RFC 2781"><titleref>RFC 2781: UTF-16, an encoding
of ISO 10646</titleref>IETF
(Internet Engineering Task Force). 
, ed. P. Hoffman, F. Yergeau. 2000.</bibl><bibl id="ISO639" key="ISO 639"><titleref>ISO 639:1988 (E).
Code for the representation of names of languages.</titleref>(International Organization for Standardization).

 [Geneva]: International
Organization for Standardization, 1988.</bibl><bibl id="ISO3166" key="ISO 3166"><titleref>ISO 3166-1:1997
(E). Codes for the representation of names of countries and their subdivisions —
Part 1: Country codes</titleref>(International Organization for Standardization).

 [Geneva]: International Organization for
Standardization, 1997.</bibl><bibl id="ISO8879" key="ISO 8879"><titleref>ISO
8879:1986(E). Information processing — Text and Office Systems —
Standard Generalized Markup Language (SGML).</titleref>ISO (International Organization for Standardization). 
 First edition —
1986-10-15. [Geneva]: International Organization for Standardization, 1986. </bibl><bibl id="ISO10744" key="ISO/IEC 10744"><emph>Extended Facilities
Annexe.</emph><titleref>ISO/IEC 10744-1992 (E). Information technology —
Hypermedia/Time-based Structuring Language (HyTime). </titleref>ISO (International Organization for
Standardization). 
 [Geneva]:
International Organization for Standardization, 1992. 
 [Geneva]: International Organization for Standardization, 1996. </bibl><bibl href="http://www.sgmlsource.com/8879/n0029.htm" id="websgml" key="WEBSGML"><titleref>ISO 8879:1986
TC2. Information technology — Document Description and Processing Languages</titleref>ISO
(International Organization for Standardization). 
.
[Geneva]: International Organization for Standardization, 1998.</bibl><bibl href="http://www.w3.org/TR/xml-names/" id="xml-names" key="XML Names"><titleref>Namespaces in XML</titleref>Tim Bray,
Dave Hollander, and Andrew Layman, editors. 
.
Textuality, Hewlett-Packard, and Microsoft. World Wide Web Consortium, 1999.</bibl>
					

					

					

					

					

					

					

					

					

					

					

					

					

					

				</blist><head>Other References</head>
				

				

				

			</div2><head>References</head>
			

			

			

		</div1><div1 id="CharClasses"><head>Character Classes</head><p diff="add"><loc href="E09" role="erratumref" /><loc href="http://www.w3.org/TR/2006/REC-xml-20060816/">Fourth Edition</loc><nt def="NT-NameStartChar">[4]</nt><nt def="NT-Name">[5]</nt>Because of changes to productions 
				
 and 
, the productions in
				this Appendix are now orphaned and not used anymore in determining
				name characters.  This Appendix may be removed in a future edition of 
				this specification; other specifications that wish to refer to the productions herein should
				do so by means of a reference to the relevant production(s) in the
				
 of this specification. </p><p>Following the characteristics defined in the Unicode standard, characters
are classed as base characters (among others, these contain the alphabetic
characters of the Latin alphabet), ideographic characters, and combining characters (among
others, this class contains most diacritics). Digits and extenders are also
distinguished.</p><p>The character classes defined here can be derived from the Unicode 2.0
character database as follows:</p><scrap id="CHARACTERS" lang="ebnf"><head>Characters</head><prodgroup pcw3="3" pcw4="15"><prod id="NT-Letter" num="84"><lhs>Letter</lhs><rhs><nt def="NT-BaseChar">BaseChar</nt><nt def="NT-Ideographic">Ideographic</nt>
							
 | 

						</rhs>
						

						

					</prod><prod id="NT-BaseChar" num="85"><lhs>BaseChar</lhs><rhs>[#x0041-#x005A] | [#x0061-#x007A] | [#x00C0-#x00D6]
| [#x00D8-#x00F6] | [#x00F8-#x00FF] | [#x0100-#x0131] | [#x0134-#x013E]
| [#x0141-#x0148] | [#x014A-#x017E] | [#x0180-#x01C3] | [#x01CD-#x01F0]
| [#x01F4-#x01F5] | [#x01FA-#x0217] | [#x0250-#x02A8] | [#x02BB-#x02C1]
| #x0386 | [#x0388-#x038A] | #x038C | [#x038E-#x03A1]
| [#x03A3-#x03CE] | [#x03D0-#x03D6] | #x03DA | #x03DC
| #x03DE | #x03E0 | [#x03E2-#x03F3] | [#x0401-#x040C]
| [#x040E-#x044F] | [#x0451-#x045C] | [#x045E-#x0481] | [#x0490-#x04C4]
| [#x04C7-#x04C8] | [#x04CB-#x04CC] | [#x04D0-#x04EB] | [#x04EE-#x04F5]
| [#x04F8-#x04F9] | [#x0531-#x0556] | #x0559 | [#x0561-#x0586]
| [#x05D0-#x05EA] | [#x05F0-#x05F2] | [#x0621-#x063A] | [#x0641-#x064A]
| [#x0671-#x06B7] | [#x06BA-#x06BE] | [#x06C0-#x06CE] | [#x06D0-#x06D3]
| #x06D5 | [#x06E5-#x06E6] | [#x0905-#x0939] | #x093D
| [#x0958-#x0961] | [#x0985-#x098C] | [#x098F-#x0990] | [#x0993-#x09A8]
| [#x09AA-#x09B0] | #x09B2 | [#x09B6-#x09B9] | [#x09DC-#x09DD]
| [#x09DF-#x09E1] | [#x09F0-#x09F1] | [#x0A05-#x0A0A] | [#x0A0F-#x0A10]
| [#x0A13-#x0A28] | [#x0A2A-#x0A30] | [#x0A32-#x0A33] | [#x0A35-#x0A36]
| [#x0A38-#x0A39] | [#x0A59-#x0A5C] | #x0A5E | [#x0A72-#x0A74]
| [#x0A85-#x0A8B] | #x0A8D | [#x0A8F-#x0A91] | [#x0A93-#x0AA8]
| [#x0AAA-#x0AB0] | [#x0AB2-#x0AB3] | [#x0AB5-#x0AB9] | #x0ABD
| #x0AE0 | [#x0B05-#x0B0C] | [#x0B0F-#x0B10] | [#x0B13-#x0B28]
| [#x0B2A-#x0B30] | [#x0B32-#x0B33] | [#x0B36-#x0B39] | #x0B3D
| [#x0B5C-#x0B5D] | [#x0B5F-#x0B61] | [#x0B85-#x0B8A] | [#x0B8E-#x0B90]
| [#x0B92-#x0B95] | [#x0B99-#x0B9A] | #x0B9C | [#x0B9E-#x0B9F]
| [#x0BA3-#x0BA4] | [#x0BA8-#x0BAA] | [#x0BAE-#x0BB5] | [#x0BB7-#x0BB9]
| [#x0C05-#x0C0C] | [#x0C0E-#x0C10] | [#x0C12-#x0C28] | [#x0C2A-#x0C33]
| [#x0C35-#x0C39] | [#x0C60-#x0C61] | [#x0C85-#x0C8C] | [#x0C8E-#x0C90]
| [#x0C92-#x0CA8] | [#x0CAA-#x0CB3] | [#x0CB5-#x0CB9] | #x0CDE
| [#x0CE0-#x0CE1] | [#x0D05-#x0D0C] | [#x0D0E-#x0D10] | [#x0D12-#x0D28]
| [#x0D2A-#x0D39] | [#x0D60-#x0D61] | [#x0E01-#x0E2E] | #x0E30
| [#x0E32-#x0E33] | [#x0E40-#x0E45] | [#x0E81-#x0E82] | #x0E84
| [#x0E87-#x0E88] | #x0E8A | #x0E8D | [#x0E94-#x0E97]
| [#x0E99-#x0E9F] | [#x0EA1-#x0EA3] | #x0EA5 | #x0EA7
| [#x0EAA-#x0EAB] | [#x0EAD-#x0EAE] | #x0EB0 | [#x0EB2-#x0EB3]
| #x0EBD | [#x0EC0-#x0EC4] | [#x0F40-#x0F47] | [#x0F49-#x0F69]
| [#x10A0-#x10C5] | [#x10D0-#x10F6] | #x1100 | [#x1102-#x1103]
| [#x1105-#x1107] | #x1109 | [#x110B-#x110C] | [#x110E-#x1112]
| #x113C | #x113E | #x1140 | #x114C | #x114E | #x1150
| [#x1154-#x1155] | #x1159 | [#x115F-#x1161] | #x1163
| #x1165 | #x1167 | #x1169 | [#x116D-#x116E] | [#x1172-#x1173]
| #x1175 | #x119E | #x11A8 | #x11AB | [#x11AE-#x11AF]
| [#x11B7-#x11B8] | #x11BA | [#x11BC-#x11C2] | #x11EB
| #x11F0 | #x11F9 | [#x1E00-#x1E9B] | [#x1EA0-#x1EF9]
| [#x1F00-#x1F15] | [#x1F18-#x1F1D] | [#x1F20-#x1F45] | [#x1F48-#x1F4D]
| [#x1F50-#x1F57] | #x1F59 | #x1F5B | #x1F5D | [#x1F5F-#x1F7D]
| [#x1F80-#x1FB4] | [#x1FB6-#x1FBC] | #x1FBE | [#x1FC2-#x1FC4]
| [#x1FC6-#x1FCC] | [#x1FD0-#x1FD3] | [#x1FD6-#x1FDB] | [#x1FE0-#x1FEC]
| [#x1FF2-#x1FF4] | [#x1FF6-#x1FFC] | #x2126 | [#x212A-#x212B]
| #x212E | [#x2180-#x2182] | [#x3041-#x3094] | [#x30A1-#x30FA]
| [#x3105-#x312C] | [#xAC00-#xD7A3] </rhs>
						

						

					</prod><prod id="NT-Ideographic" num="86"><lhs>Ideographic</lhs><rhs>[#x4E00-#x9FA5] | #x3007 | [#x3021-#x3029] </rhs>
						

						

					</prod><prod id="NT-CombiningChar" num="87"><lhs>CombiningChar</lhs><rhs>[#x0300-#x0345] | [#x0360-#x0361] | [#x0483-#x0486]
| [#x0591-#x05A1] | [#x05A3-#x05B9] | [#x05BB-#x05BD] | #x05BF
| [#x05C1-#x05C2] | #x05C4 | [#x064B-#x0652] | #x0670
| [#x06D6-#x06DC] | [#x06DD-#x06DF] | [#x06E0-#x06E4] | [#x06E7-#x06E8]
| [#x06EA-#x06ED] | [#x0901-#x0903] | #x093C | [#x093E-#x094C]
| #x094D | [#x0951-#x0954] | [#x0962-#x0963] | [#x0981-#x0983]
| #x09BC | #x09BE | #x09BF | [#x09C0-#x09C4] | [#x09C7-#x09C8]
| [#x09CB-#x09CD] | #x09D7 | [#x09E2-#x09E3] | #x0A02
| #x0A3C | #x0A3E | #x0A3F | [#x0A40-#x0A42] | [#x0A47-#x0A48]
| [#x0A4B-#x0A4D] | [#x0A70-#x0A71] | [#x0A81-#x0A83] | #x0ABC
| [#x0ABE-#x0AC5] | [#x0AC7-#x0AC9] | [#x0ACB-#x0ACD] | [#x0B01-#x0B03]
| #x0B3C | [#x0B3E-#x0B43] | [#x0B47-#x0B48] | [#x0B4B-#x0B4D]
| [#x0B56-#x0B57] | [#x0B82-#x0B83] | [#x0BBE-#x0BC2] | [#x0BC6-#x0BC8]
| [#x0BCA-#x0BCD] | #x0BD7 | [#x0C01-#x0C03] | [#x0C3E-#x0C44]
| [#x0C46-#x0C48] | [#x0C4A-#x0C4D] | [#x0C55-#x0C56] | [#x0C82-#x0C83]
| [#x0CBE-#x0CC4] | [#x0CC6-#x0CC8] | [#x0CCA-#x0CCD] | [#x0CD5-#x0CD6]
| [#x0D02-#x0D03] | [#x0D3E-#x0D43] | [#x0D46-#x0D48] | [#x0D4A-#x0D4D]
| #x0D57 | #x0E31 | [#x0E34-#x0E3A] | [#x0E47-#x0E4E]
| #x0EB1 | [#x0EB4-#x0EB9] | [#x0EBB-#x0EBC] | [#x0EC8-#x0ECD]
| [#x0F18-#x0F19] | #x0F35 | #x0F37 | #x0F39 | #x0F3E
| #x0F3F | [#x0F71-#x0F84] | [#x0F86-#x0F8B] | [#x0F90-#x0F95]
| #x0F97 | [#x0F99-#x0FAD] | [#x0FB1-#x0FB7] | #x0FB9
| [#x20D0-#x20DC] | #x20E1 | [#x302A-#x302F] | #x3099
| #x309A </rhs>
						

						

					</prod><prod id="NT-Digit" num="88"><lhs>Digit</lhs><rhs>[#x0030-#x0039] | [#x0660-#x0669] | [#x06F0-#x06F9]
| [#x0966-#x096F] | [#x09E6-#x09EF] | [#x0A66-#x0A6F] | [#x0AE6-#x0AEF]
| [#x0B66-#x0B6F] | [#x0BE7-#x0BEF] | [#x0C66-#x0C6F] | [#x0CE6-#x0CEF]
| [#x0D66-#x0D6F] | [#x0E50-#x0E59] | [#x0ED0-#x0ED9] | [#x0F20-#x0F29] </rhs>
						

						

					</prod><prod id="NT-Extender" num="89"><lhs>Extender</lhs><rhs>#x00B7 | #x02D0 | #x02D1 | #x0387 | #x0640
| #x0E46 | #x0EC6 | #x3005 | [#x3031-#x3035] | [#x309D-#x309E]
| [#x30FC-#x30FE] </rhs>
						

						

					</prod>
					

					

					

					

					

					

				</prodgroup>
				

				

			</scrap><ulist><item><p>Name start characters must have one of the categories Ll, Lu, Lo,
Lt, Nl.</p>
					

				</item><item><p>Name characters other than Name-start characters must have one of
the categories Mc, Me, Mn, Lm, or Nd.</p>
					

				</item><item><p>Characters in the compatibility area (i.e. with character code greater
than #xF900 and less than #xFFFE) are not allowed in XML names.</p>
					

				</item><item><p><quote>compatibility formatting tag</quote><quote>&lt;</quote>Characters which have a font or compatibility decomposition (i.e.
those with a 
 in field 5 of the
database -- marked by field 5 beginning with a 
) are not
allowed.</p>
					

				</item><item><p>The following characters are treated as name-start characters rather
than name characters, because the property file classifies them as Alphabetic:
[#x02BB-#x02C1], #x0559, #x06E5, #x06E6.</p>
					

				</item><item><p>Characters #x20DD-#x20E0 are excluded (in accordance with Unicode 2.0,
section 5.14).</p>
					

				</item><item><p>Character #x00B7 is classified as an extender, because the property
list so identifies it.</p>
					

				</item><item><p>Character #x0387 is added as a name character, because #x00B7 is
its canonical equivalent.</p>
					

				</item><item><p>Characters &#x27;:&#x27; and &#x27;_&#x27; are allowed as name-start characters.</p>
					

				</item><item><p>Characters &#x27;-&#x27; and &#x27;.&#x27; are allowed as name characters.</p>
					

				</item>
				

				

				

				

				

				

				

				

				

				

			</ulist>
			


			

			
			

			

			

			

		</div1><inform-div1 id="sec-xml-and-sgml"><head>XML and SGML</head><p><bibref ref="Clark" />XML
is designed to be a subset of SGML, in that every XML document should also
be a conforming SGML document. For a detailed comparison of the additional
restrictions that XML places on documents beyond those of SGML, see 
.</p>
			

			

		</inform-div1><inform-div1 id="sec-entexpand"><eg>&lt;!ENTITY example &quot;&lt;p&gt;An ampersand (&amp;#38;#38;) may be escaped
numerically (&amp;#38;#38;#38;) or with a general entity
(&amp;amp;amp;).&lt;/p&gt;&quot; &gt;</eg><eg>&lt;p&gt;An ampersand (&amp;#38;) may be escaped
numerically (&amp;#38;#38;) or with a general entity
(&amp;amp;amp;).&lt;/p&gt;</eg><eg>An ampersand (&amp;) may be escaped
numerically (&amp;#38;) or with a general entity
(&amp;amp;).</eg><eg>1 &lt;?xml version=&#x27;1.0&#x27;?&gt;
2 &lt;!DOCTYPE test [
3 &lt;!ELEMENT test (#PCDATA) &gt;
4 &lt;!ENTITY % xx &#x27;&amp;#37;zz;&#x27;&gt;
5 &lt;!ENTITY % zz &#x27;&amp;#60;!ENTITY tricky &quot;error-prone&quot; &gt;&#x27; &gt;
6 %xx;
7 ]&gt;
8 &lt;test&gt;This sample shows a &amp;tricky; method.&lt;/test&gt;</eg><eg diff="add"><loc href="E07" role="erratumref" />&lt;!DOCTYPE foo [ 
&lt;!ENTITY x &quot;&lt;&quot;&gt; 
]&gt; 
&lt;foo attr=&quot;&amp;x;&quot;/&gt;</eg><eg diff="add"><loc href="E07" role="erratumref" />&lt;!ENTITY x &quot;&amp;#60;&quot;&gt;</eg><head>Expansion of Entity and Character References</head><p><specref ref="entproc" />This appendix contains some examples illustrating the sequence of entity-
and character-reference recognition and expansion, as specified in 
.</p><p>If the DTD contains the declaration</p><p><quote><code>example</code>
					

				</quote>then the XML processor will recognize the character references when it
parses the entity declaration, and resolve them before storing the following
string as the value of the entity 
:</p><p><el>p</el><el>p</el><quote><code>&amp;example;</code>
					

				</quote>A reference in the document to 

will cause the text to be reparsed, at which time the start- and end-tags
of the 
 element will be recognized and the three references will
be recognized and expanded, resulting in a 
 element with the following
content (all data, no delimiters or markup):</p><p>A more complex example will illustrate the rules and their effects fully.
In the following example, the line numbers are solely for reference.</p><p>This produces the following:</p><p diff="add"><loc href="E07" role="erratumref" />In the following example</p><p diff="add"><loc href="E07" role="erratumref" /><specref ref="sec-predefined-ent" /><titleref href="#bypass">bypassed</titleref>the replacement text of x is the four characters &quot;&lt;&quot; because
				references to general entities in entity values are 
.
				The replacement text of lt is a character reference to
				the less-than character, for example the five characters &quot;&amp;#60;&quot;
				(see 
).  Since neither of these contains a less-than character
				the result is well-formed.</p><p diff="add"><loc href="E07" role="erratumref" />If the definition of x had been</p><p diff="add"><loc href="E07" role="erratumref" /><titleref href="#CleanAttrVals">WFC: No &lt; in Attribute Values</titleref>then the document would not have been well-formed, because the
				replacement text of x would be the single character &quot;&lt;&quot; which
				is not permitted in attribute values (see 
).</p><ulist spacing="compact"><item><p><quote><code>xx</code>
							

						</quote><quote><code>%zz;</code>
							

						</quote><quote><code>zz</code>
							

						</quote><quote><code>zz</code>
							

						</quote>in line 4, the reference to character 37 is expanded immediately,
and the parameter entity 
 is stored in the symbol
table with the value 
. Since the replacement
text is not rescanned, the reference to parameter entity 

is not recognized. (And it would be an error if it were, since 

is not yet declared.)</p>
					

				</item><item><p><quote><code>&amp;#60;</code>
							

						</quote><quote><code>zz</code>
							

						</quote><quote><code>&lt;!ENTITY tricky &quot;error-prone&quot;
&gt;</code>
							

						</quote>in line 5, the character reference 

is expanded immediately and the parameter entity 

is stored with the replacement text 
, which is a well-formed entity declaration.</p>
					

				</item><item><p><quote><code>xx</code>
							

						</quote><quote><code>xx</code>
							

						</quote><quote><code>%zz;</code>
							

						</quote><quote><code>zz</code>
							

						</quote><quote><code>&lt;!ENTITY tricky &quot;error-prone&quot;
&gt;</code>
							

						</quote><quote><code>tricky</code>
							

						</quote><quote><code>error-prone</code>
							

						</quote>in line 6, the reference to 
 is recognized,
and the replacement text of 
 (namely 
)
is parsed. The reference to 
 is recognized in
its turn, and its replacement text (
) is parsed. The general entity 

has now been declared, with the replacement text 
.</p>
					

				</item><item><p><el>test</el><emph>This sample
shows a error-prone method.</emph><quote><code>tricky</code>
							

						</quote>in line 8, the reference to the general entity 

is recognized, and it is expanded, so the full content of the 

element is the self-describing (and ungrammatical) string 

					</p>
					

				</item>
				

				

				

				

			</ulist>
			

			

			

			

			

			

			

			

			

			

			

			


			
 
			
			
 

			
 
			
			

			
			
 
			
			

		</inform-div1><inform-div1 id="determinism"><head>Deterministic Content Models</head><p><quote>unambiguous</quote><specref ref="sec-element-content" /><termref def="dt-compat">for compatibility</termref>As
noted in 
, it is required that content
models in element type declarations be deterministic. This requirement is 
 with SGML (which calls deterministic
content models 
); XML processors built
using SGML systems may flag non-deterministic content models as errors.</p><p><code>((b, c) | (b, d))</code><code>(b,
(c | d))</code><el>b</el><el>b</el><el>b</el><el>b</el><el>b</el><el>c</el><el>d</el>For example, the content model 
 is non-deterministic,
because given an initial 
 the XML processor
cannot know which 
 in the model is being matched without looking
ahead to see which element follows the 
. In this case, the two references
to 
 can be collapsed into a single reference, making the model read 
. An initial 
 now clearly matches only a single name
in the content model. The processor doesn&#x27;t need to look ahead to see what follows; either 
 or 

would be accepted.</p><p><bibref ref="Aho" />More formally: a finite state automaton may be constructed from the content
model using the standard algorithms, e.g. algorithm 3.5 in section 3.9 of
Aho, Sethi, and Ullman 
. In many such algorithms, a follow
set is constructed for each position in the regular expression (i.e., each
leaf node in the syntax tree for the regular expression); if any position
has a follow set in which more than one following position is labeled with
the same element type name, then the content model is in error and may be
reported as an error.</p><p><bibref ref="ABK" />Algorithms exist which allow many but not all non-deterministic content
models to be reduced automatically to equivalent deterministic models; see
Brüggemann-Klein 1991 
.</p>
			

			

			

			

			

		</inform-div1><inform-div1 id="sec-guessing"><div2 id="sec-guessing-no-ext-info"><head>Detection Without External Encoding Information</head><note><p>In cases above which do not require reading the encoding declaration to
determine the encoding, section 4.3.3 still requires that the encoding declaration,
if present, be read and that the encoding name be checked to match the actual
encoding of the entity. Also, it is possible that new character encodings
will be invented that will make it necessary to use the encoding declaration
to determine the encoding, in cases where this is not required at present.</p>
					

				</note><p><code>&lt;?xml</code><quote><code>#x0000003C</code>
						

					</quote><quote><code>#x0000003F</code>
						

					</quote><quote><code>#xFEFF</code>
						

					</quote><var>##</var><var>##</var>Because each XML entity not accompanied by external
encoding information and not in UTF-8 or UTF-16 encoding must
begin with an XML encoding declaration, in which the first characters must
be &#x27;
&#x27;, any conforming processor can detect, after two
to four octets of input, which of the following cases apply. In reading this
list, it may help to know that in UCS-4, &#x27;&lt;&#x27; is 

and &#x27;?&#x27; is 
, and the Byte Order Mark
required of UTF-16 data streams is 
. The notation

 is used to denote any byte value except that two consecutive

s cannot be both 00.</p><p>With a Byte Order Mark:</p><p>Without a Byte Order Mark:</p><p>This level of autodetection is enough to read the XML encoding declaration
and parse the character-encoding identifier, which is still necessary to distinguish
the individual members of each family of encodings (e.g. to tell UTF-8 from
8859, and the parts of 8859 from each other, or to distinguish the specific
EBCDIC code page in use, and so on).</p><p>Because the contents of the encoding declaration are restricted to characters
from the ASCII repertoire (however encoded),
a processor can reliably read the entire encoding declaration as soon as it
has detected which family of encodings is in use. Since in practice, all widely
used character encodings fall into one of the categories above, the XML encoding
declaration allows reasonably reliable in-band labeling of character encodings,
even when external sources of information at the operating-system or transport-protocol
level are unreliable. Character encodings such as UTF-7
that make overloaded usage of ASCII-valued bytes may fail to be reliably detected.</p><p>Once the processor has detected the character encoding in use, it can act
appropriately, whether by invoking a separate input routine for each case,
or by calling the proper conversion function on each character of input.</p><p>Like any self-labeling system, the XML encoding declaration will not work
if any software changes the entity&#x27;s character set or encoding without updating
the encoding declaration. Implementors of character-encoding routines should
be careful to ensure the accuracy of the internal and external information
used to label the entity.</p><table border="1" frame="border"><tbody><tr><td><code>00 00 FE
FF</code>
								

							</td><td>UCS-4, big-endian machine (1234 order)</td>
							

							

						</tr><tr><td><code>FF
FE 00 00</code>
								

							</td><td>UCS-4, little-endian machine (4321 order)</td>
							

							

						</tr><tr><td><code>00 00 FF FE</code>
								

							</td><td>UCS-4, unusual octet order (2143)</td>
							

							

						</tr><tr><td><code>FE FF 00 00</code>
								

							</td><td>UCS-4, unusual octet order (3412)</td>
							

							

						</tr><tr><td><code>FE FF ## ##</code>
								

							</td><td>UTF-16, big-endian</td>
							

							

						</tr><tr><td><code>FF FE ## ##</code>
								

							</td><td>UTF-16, little-endian</td>
							

							

						</tr><tr><td><code>EF BB BF</code>
								

							</td><td>UTF-8</td>
							

							

						</tr>
						

						

						

						

						

						

						

					</tbody>
					

				</table><table border="1" frame="border"><tbody><tr><td><code>00 00 00 3C</code>
								

							</td><td rowspan="4">UCS-4 or other encoding with a 32-bit code unit and ASCII
characters encoded as ASCII values, in respectively big-endian (1234), little-endian
(4321) and two unusual byte orders (2143 and 3412). The encoding declaration
must be read to determine which of UCS-4 or other supported 32-bit encodings
applies.</td>
							

							

						</tr><tr><td><code>3C 00 00 00</code>
								

							</td>
							

							

						</tr><tr><td><code>00 00 3C 00</code>
								

							</td>
							

							

						</tr><tr><td><code>00 3C 00 00</code>
								

							</td>
							

							

						</tr><tr><td><code>00 3C 00 3F</code>
								

							</td><td>UTF-16BE or big-endian ISO-10646-UCS-2
or other encoding with a 16-bit code unit in big-endian order and ASCII characters
encoded as ASCII values (the encoding declaration must be read to determine
which)</td>
							

							

						</tr><tr><td><code>3C 00 3F 00</code>
								

							</td><td>UTF-16LE or little-endian
ISO-10646-UCS-2 or other encoding with a 16-bit code unit in little-endian
order and ASCII characters encoded as ASCII values (the encoding declaration
must be read to determine which)</td>
							

							

						</tr><tr><td><code>3C 3F 78 6D</code>
								

							</td><td>UTF-8, ISO 646, ASCII, some part of ISO 8859, Shift-JIS, EUC, or any other
7-bit, 8-bit, or mixed-width encoding which ensures that the characters of
ASCII have their normal positions, width, and values; the actual encoding
declaration must be read to detect which of these applies, but since all of
these encodings use the same bit patterns for the relevant ASCII characters,
the encoding declaration itself may be read reliably</td>
							

							

						</tr><tr><td><code>4C
6F A7 94</code>
								

							</td><td>EBCDIC (in some flavor; the full encoding declaration
must be read to tell which code page is in use)</td>
							

							

						</tr><tr><td>Other</td><td>UTF-8 without an encoding declaration, or else the data stream is mislabeled
(lacking a required encoding declaration), corrupt, fragmentary, or enclosed
in a wrapper of some kind</td>
							

							

						</tr>
						

						

						

						

						

						

						

						

						

					</tbody>
					

				</table>
				

				

				

				

				

				

				

				

				

				

				

			</div2><div2 id="sec-guessing-with-ext-info"><head>Priorities in the Presence of External Encoding Information</head><p><bibref ref="rfc2376" /><code>text/xml</code><code>application/xml</code>The second possible case occurs when the XML entity is accompanied by encoding
information, as in some file systems and some network protocols. When multiple
sources of information are available, their relative priority and the preferred
method of handling conflict should be specified as part of the higher-level
protocol used to deliver XML. In particular, please refer
to 
 or its successor, which defines the 

and 
 MIME types and provides some useful guidance.
In the interests of interoperability, however, the following rule is recommended.</p><ulist><item><p>If an XML entity is in a file, the Byte-Order Mark and encoding declaration are used
(if present) to determine the character encoding.</p>
						

					</item>
					

				</ulist>
				

				

				

			</div2><head>Autodetection of Character Encodings</head><p><phrase diff="add"><loc href="E05" role="erratumref" />will</phrase><phrase diff="del"><loc href="E05" role="erratumref" />the first case first.</phrase><phrase diff="add"><loc href="E05" role="erratumref" />these cases in turn.</phrase>The XML encoding declaration functions as an internal label on each entity,
indicating which character encoding is in use. Before an XML processor can
read the internal label, however, it apparently has to know what character
encoding is in use—which is what the internal label is trying to indicate.
In the general case, this is a hopeless situation. It is not entirely hopeless
in XML, however, because XML limits the general case in two ways: each implementation
is assumed to support only a finite set of character encodings, and the XML
encoding declaration is restricted in position and content in order to make
it feasible to autodetect the character encoding in use in each entity in
normal cases. Also, in many cases other sources of information are available
in addition to the XML data stream itself. Two cases may be distinguished,
depending on whether the XML entity is presented to the processor without,
or with, any accompanying (external) information. We 
 consider


</p>
			

			

			

			

		</inform-div1><inform-div1 id="sec-xml-wg"><head>W3C XML Working Group</head><orglist><member><affiliation>Sun</affiliation><name>Jon Bosak</name><role>Chair</role>
					

					

					

				</member><member><name>James Clark</name><role>Technical Lead</role>
					

					

				</member><member><affiliation>Textuality and Netscape</affiliation><name>Tim Bray</name><role>XML Co-editor</role>
					

					

					

				</member><member><affiliation>Microsoft</affiliation><name>Jean Paoli</name><role>XML Co-editor</role>
					

					

					

				</member><member><affiliation>U. of Ill.</affiliation><name>C. M. Sperberg-McQueen</name><role>XML Co-editor</role>
					

					

					

				</member><member><affiliation>W3C</affiliation><name>Dan Connolly</name><role>W3C Liaison</role>
					

					

					

				</member><member><affiliation>Texcel</affiliation><name>Paula Angerstein</name>
					

					

				</member><member><affiliation>INSO</affiliation><name>Steve DeRose</name>
					

					

				</member><member><affiliation>HP</affiliation><name>Dave Hollander</name>
					

					

				</member><member><affiliation>ISOGEN</affiliation><name>Eliot Kimber</name>
					

					

				</member><member><affiliation>ArborText</affiliation><name>Eve Maler</name>
					

					

				</member><member><affiliation>NCSA</affiliation><name>Tom Magliery</name>
					

					

				</member><member><affiliation>SoftQuad, Grif SA, Muzmo and Veo Systems</affiliation><name>Murray Maloney</name>
					

					

				</member><member><affiliation>Fuji Xerox Information Systems</affiliation><name>MURATA Makoto (FAMILY Given)</name>
					

					

				</member><member><affiliation>Adobe</affiliation><name>Joel Nava</name>
					

					

				</member><member><affiliation>Vignette</affiliation><name>Conleth O&#x27;Connell</name>
					

					

				</member><member><affiliation>SoftQuad</affiliation><name>Peter Sharpe</name>
					

					

				</member><member><affiliation>DataChannel</affiliation><name>John Tigue</name>
					

					

				</member>
				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

			</orglist><p>This specification was prepared and approved for publication by the W3C
XML Working Group (WG). WG approval of this specification does not necessarily
imply that all WG members voted for its approval. The current and former
participants of the XML WG are:</p>
			

			

			

		</inform-div1><inform-div1 id="sec-core-wg"><head>W3C XML Core Working Group</head><orglist><member><affiliation>Google</affiliation><name>John Cowan</name>
					

					

				</member><member><affiliation>PTC-Arbortext</affiliation><name>Andrew Fang</name>
					

					

				</member><member><affiliation>PTC-Arbortext</affiliation><name>Paul Grosso</name><role>Co-Chair</role>
					

					

					

				</member><member><affiliation>A-SIT</affiliation><name>Konrad Lanz</name>
					

					

				</member><member><affiliation>IBM</affiliation><name>Glenn Marcy</name>
					

					

				</member><member><affiliation>W3C</affiliation><name>Henry Thompson</name><role>Staff Contact</role>
					

					

					

				</member><member><affiliation>University of Edinburgh</affiliation><name>Richard Tobin</name>
					

					

				</member><member><name>Daniel Veillard</name>
					

				</member><member><affiliation>Mark Logic</affiliation><name>Norman Walsh</name><role>Co-Chair</role>
					

					

					

				</member><member><name>François Yergeau</name>
					

				</member>
				

				

				

				

				

				

				

				

				

				

			</orglist><p><phrase diff="chg">fifth</phrase>The 
 edition of this specification was prepared by the W3C XML Core
Working Group (WG). The participants in the WG at the time of publication of this
edition were:</p>
			

			

			

		</inform-div1><inform-div1 id="prod-notes"><head>Production Notes</head><p diff="chg"><loc href="http://www.w3.org/2002/xmlspec/dtd/2.10/xmlspec.dtd">XMLspec DTD, v2.10</loc><loc href="http://www.w3.org/2002/xmlspec/xhtml/1.13/xmlspec.xsl">xmlspec.xsl</loc><loc href="http://www.w3.org/2002/xmlspec/xhtml/1.13/diffspec.xsl">diffspec.xsl</loc><loc href="REC-xml.xsl">REC-xml.xsl</loc>This edition was encoded in a
slightly modified version of the

.
The XHTML versions were produced with a combination of the

,

,
and 

XSLT stylesheets.</p>
			

			

		</inform-div1><inform-div1 diff="add" id="sec-suggested-names"><head><loc href="E09" role="erratumref" />Suggestions for XML Names</head><olist><item><p>The first character of any name should have a Unicode property
						of ID_Start, or else be &#x27;_&#x27; #x5F.</p>
					

				</item><item><p>Characters other than the first should have a Unicode property
						of ID_Continue, or be one of the characters listed in the table
						entitled &quot;Characters for Natural Language Identifiers&quot; in UAX
						#31, with the exception of &quot;&#x27;&quot; #x27 and &quot;’&quot; #x2019.</p>
					

				</item><item><p><bibref ref="unipart15" />Characters in names should be expressed using
Normalization Form C as defined in 
.</p></item><item><p>Ideographic characters which have a canonical decomposition
						(including those in the ranges [#xF900-#xFAFF] and
						[#x2F800-#x2FFFD], with 12 exceptions) should not be used in names.
					</p>
					

				</item><item><p>Characters which have a compatibility decomposition (those with
						a &quot;compatibility formatting tag&quot; in field 5 of the Unicode
						Character Database -- marked by field 5 beginning with a &quot;&lt;&quot;)
						should not be used in names.  This suggestion does not apply
						to characters which
						despite their compatibility decompositions are in regular use in
						their scripts, for
example #x0E33 THAI CHARACTER SARA AM or #x0EB3 LAO CHARACTER AM.</p>
					

				</item><item><p>Combining characters meant for use with symbols only (including
						those in the ranges [#x20D0-#x20EF] and [#x1D165-#x1D1AD]) should
						not be used in names.</p>
					

				</item><item><p>The interlinear annotation characters ([#xFFF9-#xFFFB]) should
						not be used in names.</p>
					

				</item><item><p>Variation selector characters should not be used in names.</p>
					

				</item><item><p>Names which are nonsensical, unpronounceable, hard to read, or
						easily confusable with other names should not be employed.</p>
					

				</item>
				

				

	

				

				

				

				

				

				

			</olist><p><loc href="E09" role="erratumref" />The following suggestions define what is believed to be best
				practice in the construction of XML names used as element names,
				attribute names, processing instruction targets, entity names,
				notation names, and the values of attributes of type ID, and are
				intended as guidance for document authors and schema designers.
				All references to Unicode are understood with respect to
				a particular version of the Unicode Standard greater than or equal
				to 5.0; which version should be used is left to the discretion of
				the document author or schema designer.</p><p><bibref ref="Unicode" />The first two suggestions are directly derived from the rules
				given for identifiers in Standard Annex #31 (UAX #31) of the Unicode Standard, version 5.0 
, and
				exclude all control characters, enclosing nonspacing marks,
				non-decimal numbers, private-use characters, punctuation characters
				(with the noted exceptions), symbol characters, unassigned
				codepoints, and white space characters. The other suggestions
				are mostly derived from Appendix B in previous editions of this specification.</p>
			

			

			

			

		</inform-div1>
		

		

		

		

		

		

		

		

		

		

		


		

	</back><body><div1 id="sec-intro"><div2 id="sec-origin-goals"><head>Origin and Goals</head><olist><item><p>XML shall be straightforwardly usable over the Internet.</p>
						

					</item><item><p>XML shall support a wide variety of applications.</p>
						

					</item><item><p>XML shall be compatible with SGML.</p>
						

					</item><item><p>It shall be easy to write programs which process XML documents.</p>
						

					</item><item><p>The number of optional features in XML is to be kept to the absolute
minimum, ideally zero.</p>
						

					</item><item><p>XML documents should be human-legible and reasonably clear.</p>
						

					</item><item><p>The XML design should be prepared quickly.</p>
						

					</item><item><p>The design of XML shall be formal and concise.</p>
						

					</item><item><p>XML documents shall be easy to create.</p>
						

					</item><item><p>Terseness in XML markup is of minimal importance.</p>
						

					</item>
					

					

					

					

					

					

					

					

					

					

				</olist><p>XML was developed by an XML Working Group (originally known as the SGML
Editorial Review Board) formed under the auspices of the World Wide Web Consortium
(W3C) in 1996. It was chaired by Jon Bosak of Sun Microsystems with the active
participation of an XML Special Interest Group (previously known as the SGML
Working Group) also organized by the W3C. The membership of the XML Working
Group is given in an appendix. Dan Connolly served as the Working Group&#x27;s contact with
the W3C.</p><p>The design goals for XML are:</p><p><bibref ref="Unicode" /><bibref ref="ISO10646" /><bibref ref="RFC1766" /><phrase diff="del">RFC 3066</phrase><phrase diff="add"><loc href="E01" role="erratumref" />BCP 47</phrase><phrase diff="add"><bibref ref="IANA-LANGCODES" /><loc href="E01" role="erratumref" />and the Language Subtag Registry </phrase><phrase diff="del"><bibref ref="ISO639" /><bibref ref="ISO3166" /><loc href="E01" role="erratumref" />, ISO 639 

					for language name codes, and ISO 3166 
 for country name codes</phrase>This specification, together with associated standards (Unicode 

					and ISO/IEC 10646 
 for characters, Internet 

					
 
 for language
					identification tags
), provides
all the information necessary to understand XML Version 1.0 and
construct computer programs to process it.</p><p>This version of the XML specification may be distributed freely, as long as
all text and legal notices remain intact.</p>
				

				

				

				

				

				

			</div2><div2 id="sec-terminology"><head>Terminology</head><p><bibref ref="rfc2119" /><glist><gitem><def><p><termdef id="dt-error" term="Error"><rfc2119>MUST</rfc2119><rfc2119>REQUIRED</rfc2119><rfc2119>MUST NOT</rfc2119><rfc2119>SHALL</rfc2119><rfc2119>SHALL NOT</rfc2119><rfc2119>MAY</rfc2119><rfc2119>MAY</rfc2119>A violation of the rules of this specification;
results are undefined. Unless otherwise specified, failure to observe a prescription of this specification indicated by one of the keywords 
, 
, 
, 
 and 
 is an error.  Conforming software 
 detect and report an error
and 
 recover from it.</termdef>
									

								</p>
								

							</def><label>error</label>
							

							

						</gitem><gitem><def><p><termdef id="dt-fatal" term="Fatal Error"><rfc2119>MUST</rfc2119><rfc2119>MAY</rfc2119><rfc2119>MAY</rfc2119><rfc2119>MAY</rfc2119><rfc2119>MUST NOT</rfc2119><rfc2119>MUST NOT</rfc2119><termref def="dt-xml-proc">XML processor</termref>An error which a conforming 

										
 detect and report to the application.
After encountering a fatal error, the processor 
 continue processing the
data to search for further errors and 
 report such errors to the application.
In order to support correction of errors, the processor 
 make unprocessed
data from the document (with intermingled character data and markup) available
to the application. Once a fatal error is detected, however, the processor

 continue normal processing (i.e., it 
 continue to pass character
data and information about the document&#x27;s logical structure to the application
in the normal way).</termdef>
									

								</p>
								

							</def><label>fatal error</label>
							

							

						</gitem><gitem><def><p><termdef id="dt-atuseroption" term="At user option"><rfc2119>MAY</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119>Conforming software

 or 
 (depending on the modal verb in the sentence) behave as described;
if it does, it 
 provide users a means to enable or disable the behavior
described.</termdef>
									

								</p>
								

							</def><label>at user option</label>
							

							

						</gitem><gitem><def><p><termdef id="dt-vc" term="Validity constraint"><rfc2119>MUST</rfc2119><termref def="dt-valid">valid</termref><termref def="dt-validating">validating XML processors</termref>A rule which applies to
all 
 XML documents. Violations of validity
constraints are errors; they 
, at user option, be reported by 
.</termdef>
									

								</p>
								

							</def><label>validity constraint</label>
							

							

						</gitem><gitem><def><p><termdef id="dt-wfc" term="Well-formedness constraint"><termref def="dt-wellformed">well-formed</termref><termref def="dt-fatal">fatal errors</termref>A rule which applies
to all 
 XML documents. Violations
of well-formedness constraints are 
.</termdef>
									

								</p>
								

							</def><label>well-formedness constraint</label>
							

							

						</gitem><gitem><def><p><termdef id="dt-match" term="match"><specref ref="elementvalid" />(Of strings or names:) Two strings
or names being compared are identical. Characters with multiple possible
representations in ISO/IEC 10646 (e.g. characters with both precomposed and
base+diacritic forms) match only if they have the same representation in both
strings. No
case folding is performed. (Of strings and rules in the grammar:) A string
matches a grammatical production if it belongs to the language generated by
that production. (Of content and content models:) An element matches its declaration
when it conforms in the fashion described in the constraint 
.</termdef>
									

								</p>
								

							</def><label>match</label>
							

							

						</gitem><gitem><def><p><termdef id="dt-compat" term="For Compatibility">Marks
a sentence describing a feature of XML included solely to ensure
that XML remains compatible with SGML.</termdef>
									

								</p>
								

							</def><label>for compatibility</label>
							

							

						</gitem><gitem><def><p><termdef id="dt-interop" term="For interoperability">Marks
a sentence describing a non-binding recommendation included to increase
the chances that XML documents can be processed by the existing installed
base of SGML processors which predate the &quot;WebSGML Adaptations Annex to ISO 879.</termdef>
									

								</p>
								

							</def><label>for interoperability</label>
							

							

						</gitem>
						

						

						

						

						

						

						

						

					</glist><rfc2119>MUST</rfc2119><rfc2119>MUST NOT</rfc2119><rfc2119>REQUIRED</rfc2119><rfc2119>SHALL</rfc2119><rfc2119>SHALL NOT</rfc2119><rfc2119>SHOULD</rfc2119><rfc2119>SHOULD NOT</rfc2119><rfc2119>RECOMMENDED</rfc2119><rfc2119>MAY</rfc2119><rfc2119>OPTIONAL</rfc2119><rfc2119>EMPHASIZED</rfc2119>The terminology used to describe XML documents is defined in the body of
this specification. The key words 
, 
,

, 
, 
,

, 
, 
,

, and 
, when 
,
are to be interpreted as described in 
. In addition, the terms defined
in the following list are used in building
those definitions and in describing the actions of an XML processor:

				</p>
				

				

			</div2><head>Introduction</head><p><bibref ref="ISO8879" /><termref def="dt-xml-doc">XML documents</termref>Extensible Markup Language, abbreviated XML, describes a class of data
objects called 
 and partially
describes the behavior of computer programs which process them. XML is an
application profile or restricted form of SGML, the Standard Generalized Markup
Language 
. By construction, XML documents are conforming
SGML documents.</p><p><termref def="dt-entity">entities</termref><termref def="dt-character">characters</termref><termref def="dt-chardata">character
data</termref><termref def="dt-markup">markup</termref>XML documents are made up of storage units called 
,
which contain either parsed or unparsed data. Parsed data is made up of 
, some of which form 
, and some of which form 
.
Markup encodes a description of the document&#x27;s storage layout and logical
structure. XML provides a mechanism to impose constraints on the storage layout
and logical structure.</p><p><termdef id="dt-xml-proc" term="XML Processor"><term>XML processor</term>A software module called
an 
 is used to read XML documents and provide access
to their content and structure.</termdef><termdef id="dt-app" term="Application"><term>application</term>It
is assumed that an XML processor is doing its work on behalf of another module,
called the 
.</termdef>
				

				
 This specification describes
the required behavior of an XML processor in terms of how it must read XML
data and the information it must provide to the application.</p>
			

			

			

			

			

			

		</div1><div1 id="sec-documents"><div2 id="sec-well-formed"><head>Well-Formed XML Documents</head><olist><item><p><nt def="NT-document">document</nt>Taken as a whole, it matches the production labeled 
.</p>
						

					</item><item><p>It meets all the well-formedness constraints given in this specification.</p>
						

					</item><item><p><termref def="dt-parsedent">parsed entities</termref><termref def="dt-wellformed">well-formed</termref>Each of the 

which is referenced directly or indirectly within the document is 
.</p>
						

					</item>
					

					

					

				</olist><olist><item><p><termref def="dt-element">elements</termref>It contains one or more 
.</p>
						

					</item><item><p><termdef id="dt-root" term="Root Element"><term>root</term><termref def="dt-content">content</termref>There is exactly one element,
called the 
, or document element, no part of which appears
in the 
 of any other element.</termdef><termref def="dt-stag">start-tag</termref><termref def="dt-etag">end-tag</termref>
							
 For
all other elements, if the 
 is in
the content of another element, the 

is in the content of the same element. More simply stated, the elements,
delimited by start- and end-tags, nest properly within each other.</p>
						

					</item>
					

					

					

				</olist><p><termdef id="dt-wellformed" term="Well-Formed"><term>well-formed</term> A textual object is a 

XML document if:</termdef>
					

				</p><p><nt def="NT-document">document</nt>Matching the 
 production implies that:</p><p><termdef id="dt-parentchild" term="Parent/Child"><el>C</el><el>P</el><el>C</el><el>P</el><el>P</el><el>P</el><el>C</el><el>C</el><el>P</el><term>parent</term><term>child</term>As a consequence of this,
for each non-root element 
 in the document, there is one other element 

in the document such that 
 is in the content of 
, but
is not in the content of any other element that is in the content of 
. 

is referred to as the 
 of 
, and 
 as
a 
 of 
.</termdef>
					

				</p><scrap id="document" lang="ebnf"><head>Document</head><prod id="NT-document" num="1"><lhs>document</lhs><rhs><nt def="NT-prolog">prolog</nt><nt def="NT-element">element</nt><nt def="NT-Misc">Misc</nt>
							

							

							
*</rhs>
						

						

					</prod>
					

					

				</scrap>
				

				

				

				

				

				

				

			</div2><div2 id="charsets"><head>Characters</head><note><eg><phrase diff="chg"><loc href="E02" role="erratumref" />E</phrase>[#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFD
F],
[#x1FFFE-#x1FFFF], [#x2FFFE-#x2FFFF], [#x3FFFE-#x3FFFF],
[#x4FFFE-#x4FFFF], [#x5FFFE-#x5FFFF], [#x6FFFE-#x6FFFF],
[#x7FFFE-#x7FFFF], [#x8FFFE-#x8FFFF], [#x9FFFE-#x9FFFF],
[#xAFFFE-#xAFFFF], [#xBFFFE-#xBFFFF], [#xCFFFE-#xCFFFF],
[#xDFFFE-#xDFFFF], [#xEFFFE-#xEFFFF], [#xFFFFE-#xFFFFF],
[#x10FFFE-#x10FFFF].</eg><p><bibref ref="Unicode" /><phrase diff="chg"><loc href="E11" role="erratumref" />2.3</phrase><phrase diff="del"><bibref ref="Unicode3" /><loc href="E11" role="erratumref" /> (see also D21 in section 3.6 of

)</phrase><quote>compatibility characters</quote>Document authors are encouraged to avoid

, as defined
in section 
 of 
. The characters defined in the following ranges are also
discouraged. They are either control characters or permanently undefined Unicode
characters:</p>
					



				</note><p><termdef id="dt-text" term="Text"><term>text</term><termref def="dt-character">characters</termref>A parsed entity contains 
,
a sequence of 
, which may
represent markup or character data.</termdef><termdef id="dt-character" term="Character"><bibref ref="ISO10646" /><nt def="NT-Char">Char</nt><rfc2119>MUST</rfc2119><specref ref="sec-existing-stds" /><term>character</term>A 

is an atomic unit of text as specified by ISO/IEC 10646:2000 
. Legal characters are tab, carriage
return, line feed, and the legal characters
of Unicode and ISO/IEC 10646. The
versions of these standards cited in 
 were
current at the time this document was prepared. New characters may be added
to these standards by amendments or new editions. Consequently, XML processors

 accept any character in the range specified for 
.
</termdef>
					

					

				</p><p><phrase diff="del"><loc href="E11" role="erratumref" /> 3.1</phrase><phrase diff="chg"><bibref ref="Unicode" /><loc href="E11" role="erratumref" /></phrase><rfc2119>MUST</rfc2119><specref ref="charencoding" />The mechanism for encoding character code points into bit patterns may
vary from entity to entity. All XML processors 
 accept the UTF-8 and UTF-16
encodings of Unicode
 
;
the mechanisms for signaling which of the two is in use,
or for bringing other encodings into play, are discussed later, in 
.</p><scrap id="char32" lang="ebnf"><head>Character Range</head><prodgroup pcw2="4" pcw4="17.5" pcw5="11"><prod id="NT-Char" num="2"><com>any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.</com><lhs>Char</lhs><rhs>#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]</rhs>
							

							

							

						</prod>
						

					</prodgroup>
					

					

				</scrap>
				

				

				

				

				

				

			</div2><div2 id="sec-common-syn"><head>Common Syntactic Constructs</head><note><p><loc href="http://www.w3.org/TR/1998/REC-xml-19980210">First Edition</loc><specref ref="sec-line-ends" />The presence of #xD in the above production is
	maintained purely for backward compatibility with the
	
.
	As explained in 
,
	all #xD characters literally present in an XML document
	are either removed or replaced by #xA characters before
	any other processing is done. The only way to get a #xD character to match this production is to
  use a character reference in an entity value literal.</p>
					

				</note><note><p><bibref ref="xml-names" />The
Namespaces in XML Recommendation 
 assigns a meaning
to names containing colon characters. Therefore, authors should not use the
colon in XML names except for namespace purposes, but XML processors must
accept the colon as a name character.</p>
					

				</note><note><p><nt def="NT-Names">Names</nt><nt def="NT-Nmtokens">Nmtokens</nt><specref ref="sec-attribute-types" />The 

and 
 productions are used to define the validity
of tokenized attribute values after normalization (see 
).</p>
					

				</note><note><p><code>&lt;</code><code>&lt;!ENTITY mylt &quot;&lt;&quot;&gt;</code><nt def="NT-EntityValue">EntityValue</nt>Although
the 
 production allows the definition
of a general entity consisting of a single explicit 
 in the literal
(e.g., 
), it is strongly advised to avoid
this practice since any reference to that entity will cause a well-formedness
error.</p>
					

				</note><p>This section defines some symbols used widely in the grammar.</p><p><nt def="NT-S">S</nt>
					
 (white space) consists of one or more space (#x20)
characters, carriage returns, line feeds, or tabs.</p><p diff="del"><loc href="E09" role="erratumref" /><specref ref="CharClasses" />Characters are classified for convenience as letters, digits, or other
characters. A
letter consists of an alphabetic or syllabic base character or an ideographic
character. Full definitions of the specific characters in each class
are given in 
.</p><p><nt def="NT-Nmtoken">Nmtoken</nt>An 
 (name token) is any mixture of name
characters.</p><p diff="del"><loc href="E09" role="erratumref" /><termdef id="dt-name-x" term="Name"><term>Name</term>A 
 is a token beginning
with a letter or one of a few punctuation characters, and continuing with
letters, digits, hyphens, underscores, colons, or full stops, together known
as name characters.</termdef>
					</p><p diff="add"><loc href="E09" role="erratumref" /><nt def="NT-Name">Names</nt><termdef id="dt-name" term="Name"><nt def="NT-Name">Name</nt><nt def="NT-Nmtoken">Nmtoken</nt>A 
 is an 
 with a restricted set of initial characters.</termdef>  Disallowed initial characters for 
 include digits, diacritics, the full stop and the hyphen.</p><p><code>((&#x27;X&#x27;|&#x27;x&#x27;) (&#x27;M&#x27;|&#x27;m&#x27;) (&#x27;L&#x27;|&#x27;l&#x27;))</code><quote><code>xml</code></quote>Names beginning with the string 
,
or with any string which would match 
,
are reserved for standardization in this or future versions of this specification.</p><p diff="add"><loc href="E09" role="erratumref" /><nt def="NT-Name">Name</nt><nt def="NT-NameStartChar">NameStartChar</nt><nt def="NT-NameChar">NameChars</nt><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><specref ref="sec-suggested-names" />The first character of a 
 
 be a 
, and any
					other characters 
 be 
; this mechanism is used to
					prevent names from beginning with European (ASCII) digits or with
					basic combining characters. Almost all characters are permitted in
					names, except those which either are or reasonably could be used as
					delimiters. The intention is to be inclusive rather than exclusive,
					so that writing systems not yet encoded in Unicode can be used in
					XML names. See 
 for suggestions on the creation of
					names.</p><p diff="add"><loc href="E09" role="erratumref" />Document authors are encouraged to use names which are
					meaningful words or combinations of words in natural languages, and
					to avoid symbolic or white space characters in names. Note that
					COLON, HYPHEN-MINUS, FULL STOP (period), LOW LINE (underscore), and
					MIDDLE DOT are explicitly permitted.</p><p diff="add"><emph>cannot</emph><loc href="E09" role="erratumref" />The ASCII symbols and punctuation marks, along with a fairly
					large group of Unicode symbol characters, are excluded from names
					because they are more useful as delimiters in contexts where XML
					names are used outside XML documents; providing this group gives
					those contexts hard guarantees about what 
 be part of
					an XML name. The character #x037E, GREEK QUESTION MARK, is excluded
					because when normalized it becomes a semicolon, which could change
					the meaning of entity references.</p><p><nt def="NT-EntityValue">EntityValue</nt><nt def="NT-AttValue">AttValue</nt><nt def="NT-SystemLiteral">SystemLiteral</nt><nt def="NT-SystemLiteral">SystemLiteral</nt>Literal data is any quoted string not containing the quotation mark used
as a delimiter for that string. Literals are used for specifying the content
of internal entities (
), the values
of attributes (
), and external identifiers
(
). Note that a 

can be parsed without scanning for markup.</p><scrap id="white" lang="ebnf"><head>White Space</head><prodgroup pcw2="4" pcw4="17.5" pcw5="11"><prod id="NT-S" num="3"><lhs>S</lhs><rhs>(#x20 | #x9 | #xD | #xA)+</rhs>
							

							

						</prod>
						

					</prodgroup>
					

					

				</scrap><scrap lang="ebnf"><head>Names and Tokens</head><prod id="NT-NameStartChar" num="4"><com diff="chg"><loc href="E09" role="erratumref" /></com><lhs diff="chg">NameStartChar</lhs><rhs diff="chg">&quot;:&quot; | [A-Z] | &quot;_&quot; | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</rhs>
						

						

						

					</prod><prod diff="add" id="NT-NameChar" num="4a"><com diff="add"><loc href="E09" role="erratumref" /></com><lhs>NameChar</lhs><rhs><nt def="NT-NameStartChar">NameStartChar</nt> | &quot;-&quot; | &quot;.&quot; | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]</rhs>
						

						

						

					</prod><prod id="NT-Name" num="5"><com diff="chg"><loc href="E09" role="erratumref" /></com><lhs>Name</lhs><rhs diff="chg"><nt def="NT-NameStartChar">NameStartChar</nt><nt def="NT-NameChar">NameChar</nt> (
)*</rhs>
						

						

						

					</prod><prod id="NT-Names" num="6"><lhs>Names</lhs><rhs><nt def="NT-Name">Name</nt><nt def="NT-Name">Name</nt> (#x20 
)*</rhs>
						

						

					</prod><prod id="NT-Nmtoken" num="7"><lhs>Nmtoken</lhs><rhs><nt def="NT-NameChar">NameChar</nt>(
)+</rhs>
						

						

					</prod><prod id="NT-Nmtokens" num="8"><lhs>Nmtokens</lhs><rhs><nt def="NT-Nmtoken">Nmtoken</nt><nt def="NT-Nmtoken">Nmtoken</nt> (#x20 
)*</rhs>
						

						

					</prod>
					

					

					

					

					

					

					

				</scrap><scrap lang="ebnf"><head>Literals</head><prod id="NT-EntityValue" num="9"><lhs>EntityValue</lhs><rhs><nt def="NT-PEReference">PEReference</nt><nt def="NT-Reference">Reference</nt>&#x27;&quot;&#x27; ([^%&amp;&quot;] | 

| 
)* &#x27;&quot;&#x27; </rhs><rhs><nt def="NT-PEReference">PEReference</nt><nt def="NT-Reference">Reference</nt>|  &quot;&#x27;&quot; ([^%&amp;&#x27;] | 
 | 
)* &quot;&#x27;&quot;</rhs>
						

						

						

					</prod><prod id="NT-AttValue" num="10"><lhs>AttValue</lhs><rhs><nt def="NT-Reference">Reference</nt>&#x27;&quot;&#x27; ([^&lt;&amp;&quot;] | 
)*
&#x27;&quot;&#x27; </rhs><rhs><nt def="NT-Reference">Reference</nt>|  &quot;&#x27;&quot; ([^&lt;&amp;&#x27;] | 
)*
&quot;&#x27;&quot;</rhs>
						

						

						

					</prod><prod id="NT-SystemLiteral" num="11"><lhs>SystemLiteral</lhs><rhs>(&#x27;&quot;&#x27; [^&quot;]* &#x27;&quot;&#x27;) | (&quot;&#x27;&quot; [^&#x27;]* &quot;&#x27;&quot;) </rhs>
						

						

					</prod><prod id="NT-PubidLiteral" num="12"><lhs>PubidLiteral</lhs><rhs><nt def="NT-PubidChar">PubidChar</nt><nt def="NT-PubidChar">PubidChar</nt>&#x27;&quot;&#x27; 
* &#x27;&quot;&#x27;
| &quot;&#x27;&quot; (
 - &quot;&#x27;&quot;)* &quot;&#x27;&quot;</rhs>
						

						

					</prod><prod id="NT-PubidChar" num="13"><lhs>PubidChar</lhs><rhs>#x20 | #xD | #xA | [a-zA-Z0-9] | [-&#x27;()+,./:=?;!*#@$_%]</rhs>
						

						

					</prod>
					

					

					

					

					

					

				</scrap>
				

				

				

				

				


				


				

				

    

    

				


				

				
				

				
				

				
				


				

				

				

				

			</div2><div2 id="syntax"><head>Character Data and Markup</head><p><termdef id="dt-markup" term="Markup"><nt def="NT-XMLDecl">XML declarations</nt><nt def="NT-TextDecl">text declarations</nt><term>Markup</term><termref def="dt-stag">start-tags</termref><termref def="dt-etag">end-tags</termref><termref def="dt-empty">empty-element tags</termref><termref def="dt-entref">entity references</termref><termref def="dt-charref">character
references</termref><termref def="dt-comment">comments</termref><termref def="dt-cdsection">CDATA section</termref><termref def="dt-doctype">document
type declarations</termref><termref def="dt-pi">processing instructions</termref>
						
 takes the form of 
, 
, 
, 
, 
, 
, 
 delimiters, 
, 
, 
, 
,
and any white space that is at the top level of the document entity (that
is, outside the document element and not inside any other markup).</termdef><termref def="dt-text">Text</termref><termref def="dt-chardata">character data</termref>
					
 consists of intermingled 
 and markup. 

				</p><p><termdef id="dt-chardata" term="Character Data"><term>character data</term>All text that is not markup
constitutes the 
 of the document.</termdef>
					

				</p><p><quote><code>&amp;</code>
						

					</quote><quote><code>&lt;</code>
						

					</quote><quote><code>&gt;</code>
						

					</quote><quote><code>&gt;</code>
						

					</quote><quote><code>]]&gt;</code>
						

					</quote><rfc2119>MUST NOT</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><termref def="dt-comment">comment</termref><termref def="dt-pi">processing
instruction</termref><termref def="dt-cdsection">CDATA section</termref><termref def="dt-escape">escaped</termref><termref def="dt-charref">numeric character references</termref><termref def="dt-compat">for compatibility</termref><termref def="dt-cdsection">CDATA
section</termref>The ampersand character (&amp;) and the left angle bracket (&lt;) 
 appear
in their literal form, except when used as markup delimiters, or
within a 
, a 
, or a 
.


If they are needed elsewhere, they 
 be 

using either 

or the strings 
 and 

respectively. The right angle bracket (&gt;) may be represented using the string 
,
and 
, 
, be escaped
using either 
 or a character reference when it
appears in the string 
 in content, when
that string is not marking the end of a 
.</p><p><quote><code>]]&gt;</code>
						

					</quote><quote><code>]]&gt;</code>
						

					</quote>In the content of elements, character data is any string of characters
which does not contain the start-delimiter of any markup and does not include the CDATA-section-close
delimiter, 
. In a CDATA section,
character data is any string of characters not including the CDATA-section-close
delimiter, 
.</p><p><quote><code>&amp;apos;</code>
						

					</quote><quote><code>&quot;</code>
						

					</quote>To allow attribute values to contain both single and double quotes, the
apostrophe or single-quote character (&#x27;) may be represented as 
,
and the double-quote character (&quot;) as 
.</p><scrap lang="ebnf"><head>Character Data</head><prod id="NT-CharData" num="14"><lhs>CharData</lhs><rhs>[^&lt;&amp;]* - ([^&lt;&amp;]* &#x27;]]&gt;&#x27; [^&lt;&amp;]*)</rhs>
						

						

					</prod>
					

					

				</scrap>
				

				

				

				

				

				

				

			</div2><div2 id="sec-comments"><eg>&lt;!-- declarations for &lt;head&gt; &amp; &lt;body&gt; --&gt;</eg><eg>&lt;!-- B+, B, or B---&gt;</eg><head>Comments</head><p><rfc2119>MUST NOT</rfc2119><termdef id="dt-comment" term="Comment"><quote><code>--</code>
							

						</quote><rfc2119>MAY</rfc2119><rfc2119>MUST NOT</rfc2119><term>Comments</term><termref def="dt-markup">markup</termref><termref def="dt-chardata">character
data</termref><termref def="dt-compat">For
compatibility</termref>
						
 may appear
anywhere in a document outside other 
;
in addition, they may appear within the document type declaration at places
allowed by the grammar. They are not part of the document&#x27;s 
; an XML processor 
, but need not, make it possible for an
application to retrieve the text of comments. 
, the string 
 (double-hyphen)

 occur within comments.</termdef>
					
 Parameter
entity references 
 be recognized within comments.</p><p>An example of a comment:</p><p><code>---&gt;</code><emph>not</emph>Note
that the grammar does not allow a comment ending in 
. The
following example is 
 well-formed.</p><scrap lang="ebnf"><head>Comments</head><prod id="NT-Comment" num="15"><lhs>Comment</lhs><rhs><nt def="NT-Char">Char</nt><nt def="NT-Char">Char</nt>&#x27;&lt;!--&#x27; ((
 - &#x27;-&#x27;) | (&#x27;-&#x27;
(
 - &#x27;-&#x27;)))* &#x27;--&gt;&#x27;</rhs>
						

						

					</prod>
					

					

				</scrap>
				

				

				

				

				

				

				

			</div2><div2 id="sec-pi"><head>Processing Instructions</head><p><termdef id="dt-pi" term="Processing instruction"><term>Processing instructions</term>
						

(PIs) allow documents to contain instructions for applications.</termdef>
					

				</p><p><nt def="NT-PITarget">PITarget</nt><quote><code>XML</code>
						

					</quote><quote><code>xml</code>
						

					</quote><rfc2119>MUST</rfc2119><rfc2119>MUST NOT</rfc2119><termref def="dt-chardata">character
data</termref><termref def="dt-notation">Notation</termref>PIs are not part of the document&#x27;s 
, but 
 be passed through to the application. The PI begins
with a target (
) used to identify the application
to which the instruction is directed. The target names 
, 
,
and so on are reserved for standardization in this or future versions of this
specification. The XML 
 mechanism
may be used for formal declaration of PI targets. Parameter
entity references 
 be recognized within processing instructions.</p><scrap lang="ebnf"><head>Processing Instructions</head><prod id="NT-PI" num="16"><lhs>PI</lhs><rhs><nt def="NT-PITarget">PITarget</nt><nt def="NT-S">S</nt><nt def="NT-Char">Char</nt><nt def="NT-Char">Char</nt><nt def="NT-Char">Char</nt>&#x27;&lt;?&#x27; 
 (

(
* - (
* &#x27;?&gt;&#x27; 
*)))? &#x27;?&gt;&#x27;</rhs>
						

						

					</prod><prod id="NT-PITarget" num="17"><lhs>PITarget</lhs><rhs><nt def="NT-Name">Name</nt>
							
 - ((&#x27;X&#x27; | &#x27;x&#x27;) (&#x27;M&#x27; |
&#x27;m&#x27;) (&#x27;L&#x27; | &#x27;l&#x27;))</rhs>
						

						

					</prod>
					

					

					

				</scrap>
				

				

				

				

			</div2><div2 id="sec-cdata-sect"><eg>&lt;![CDATA[&lt;greeting&gt;Hello, world!&lt;/greeting&gt;]]&gt; </eg><head>CDATA Sections</head><p><termdef id="dt-cdsection" term="CDATA Section"><quote><code>&lt;![CDATA[</code>
							

						</quote><quote><code>]]&gt;</code>
							

						</quote><term>CDATA sections</term>
						
 may occur anywhere character data may occur; they are used to escape blocks
of text containing characters which would otherwise be recognized as markup.
CDATA sections begin with the string 

and end with the string 
:</termdef>
					

				</p><p><nt def="NT-CDEnd">CDEnd</nt><quote><code>&lt;</code>
						

					</quote><quote><code>&amp;</code>
						

					</quote>Within a CDATA section, only the 
 string is
recognized as markup, so that left angle brackets and ampersands may occur
in their literal form; they need not (and cannot) be escaped using 

and 
. CDATA sections cannot nest.</p><p><quote><code>&lt;greeting&gt;</code>
						

					</quote><quote><code>&lt;/greeting&gt;</code>
						

					</quote><termref def="dt-chardata">character data</termref><termref def="dt-markup">markup</termref>An example of a CDATA section, in which 

and 
 are recognized as 
, not 
:</p><scrap lang="ebnf"><head>CDATA Sections</head><prod id="NT-CDSect" num="18"><lhs>CDSect</lhs><rhs><nt def="NT-CDStart">CDStart</nt><nt def="NT-CData">CData</nt><nt def="NT-CDEnd">CDEnd</nt>
							

							

							

						</rhs>
						

						

					</prod><prod id="NT-CDStart" num="19"><lhs>CDStart</lhs><rhs>&#x27;&lt;![CDATA[&#x27;</rhs>
						

						

					</prod><prod id="NT-CData" num="20"><lhs>CData</lhs><rhs><nt def="NT-Char">Char</nt><nt def="NT-Char">Char</nt><nt def="NT-Char">Char</nt>(
* - (
*
&#x27;]]&gt;&#x27; 
*)) </rhs>
						

						

					</prod><prod id="NT-CDEnd" num="21"><lhs>CDEnd</lhs><rhs>&#x27;]]&gt;&#x27;</rhs>
						

						

					</prod>
					

					

					

					

					

				</scrap>
				

				

				

				

				

				

			</div2><div2 id="sec-prolog-dtd"><eg>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;greeting&gt;Hello, world!&lt;/greeting&gt; </eg><eg>&lt;greeting&gt;Hello, world!&lt;/greeting&gt;</eg><eg>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE greeting SYSTEM &quot;hello.dtd&quot;&gt;
&lt;greeting&gt;Hello, world!&lt;/greeting&gt; </eg><eg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE greeting [
  &lt;!ELEMENT greeting (#PCDATA)&gt;
]&gt;
&lt;greeting&gt;Hello, world!&lt;/greeting&gt;</eg><head>Prolog and Document Type Declaration</head><note diff="add"><p><loc href="E10" role="erratumref" />When an XML 1.0 processor encounters a document that specifies
						a 1.x version number other than &#x27;1.0&#x27;, it will process it as
						a 1.0 document.  This means that an XML 1.0 processor will accept
						1.x documents provided they do not use any non-1.0 features.</p>
					

				</note><p><termdef id="dt-xmldecl" term="XML Declaration"><rfc2119>SHOULD</rfc2119><term>XML declaration</term>XML documents 

begin with an 
 which specifies the version of
XML being used.</termdef><termref def="dt-wellformed">well-formed</termref><termref def="dt-valid">valid</termref>
					
 For example, the following is a complete XML document, 
 but not 
:</p><p>and so is this:</p><p><termdef id="dt-valid" term="Validity"><term>valid</term>An XML document is 
 if it has an associated
document type declaration and if the document complies with the constraints
expressed in it.</termdef><termref def="dt-doctype">document
type declaration</termref>The function of the markup in an XML document is to describe its storage and
logical structure and to associate attribute
name-value pairs with its logical structures. XML provides a mechanism, the

, to define constraints on the logical structure
and to support the use of predefined storage units. 

				</p><p><rfc2119>MUST</rfc2119><termref def="dt-element">element</termref>The document type declaration 
 appear before the first 

in the document.</p><p diff="add"><loc href="E10" role="erratumref" /><nt def="NT-VersionNum">VersionNum</nt><rfc2119>SHOULD NOT</rfc2119>Even though the 
 production matches
					any version number of the form &#x27;1.x&#x27;, XML 1.0 documents 
 specify a version number other than &#x27;1.0&#x27;.</p><p><termdef id="dt-doctype" term="Document Type Declaration"><term>document
type declaration</term><term>DTD</term><termref def="dt-markupdecl">markup
declarations</termref><termref def="dt-extent">external entity</termref>The XML 
 contains or points to 
 that provide a grammar for a class of documents. This
grammar is known as a document type definition, or 
. The document
type declaration can point to an external subset (a special kind of 
) containing markup declarations,
or can contain the markup declarations directly in an internal subset, or
can do both. The DTD for a document consists of both subsets taken together.</termdef>
					

				</p><p><specref ref="sec-physical-struct" /><termdef id="dt-markupdecl" term="markup declaration"><term>markup declaration</term><termref def="dt-eldecl">element type declaration</termref><termref def="dt-attdecl">attribute-list declaration</termref><termref def="dt-entdecl">entity
declaration</termref><termref def="dt-notdecl">notation declaration</termref> A 

is an 
, an 
, an 
, or a 
.</termdef><termref def="dt-PE">parameter
entities</termref>
					

These declarations may be contained in whole or in part within 
, as described in the well-formedness and validity constraints
below. For further
information, see 
.</p><p><nt def="NT-doctypedecl">doctypedecl</nt>Note
that it is possible to construct a well-formed document containing a 

that neither points to an external subset nor contains an internal subset.</p><p><emph>after</emph><nt def="NT-elementdecl">elementdecl</nt><nt def="NT-AttlistDecl">AttlistDecl</nt><termref def="dt-repltext">replacement text</termref><termref def="dt-PE">parameter
entities</termref><termref def="dt-include">included</termref>The markup declarations may be made up in whole or in part of the 
 of 
. The productions later in this specification for individual
nonterminals (
, 
,
and so on) describe the declarations 
 all the parameter
entities have been 
.</p><p><specref ref="sec-condition-sect" />Parameter
entity references are recognized anywhere in the DTD (internal and external
subsets and external parameter entities), except in literals, processing instructions,
comments, and the contents of ignored conditional sections (see 
).
They are also recognized in entity value literals. The use of parameter entities
in the internal subset is restricted as described below.</p><p><nt def="NT-DeclSep">DeclSep</nt><nt def="NT-markupdecl">markupdecl</nt><rfc2119>MUST</rfc2119><termref def="dt-PERef">parameter-entity references</termref><termref def="dt-cond-section">conditional section</termref>Like the internal subset, the external subset and any external parameter
entities referenced
in a 

					
 consist of a series of
complete markup declarations of the types allowed by the non-terminal symbol 
, interspersed with white space or 
. However, portions of
the contents of the external subset or of these
external parameter entities may conditionally be ignored by using the 
 construct; this is not
allowed in the internal subset but is
allowed in external parameter entities referenced in the internal subset.</p><p><emph>within</emph><emph>between</emph><termref def="dt-PERef">parameter-entity
references</termref>The external subset and external parameter entities also differ from the
internal subset in that in them, 
 are permitted 
 markup declarations,
not only 
 markup declarations.</p><p>An example of an XML document with a document type declaration:</p><p><quote><code>hello.dtd</code>
						

					</quote><termref def="dt-sysid">system identifier</termref>The 

					

gives the address (a URI reference) of a DTD for the document.</p><p>The declarations can also be given locally, as in this example:</p><p><rfc2119>MUST</rfc2119>If both the external and internal subsets are used, the internal subset

 be considered to occur before the external subset. 

This has the effect that entity and attribute-list declarations in the internal
subset take precedence over those in the external subset.</p><scrap id="xmldoc" lang="ebnf"><head>Prolog</head><prodgroup pcw2="6" pcw4="17.5" pcw5="9"><prod id="NT-prolog" num="22"><lhs>prolog</lhs><rhs><nt def="NT-XMLDecl">XMLDecl</nt><nt def="NT-Misc">Misc</nt><nt def="NT-doctypedecl">doctypedecl</nt><nt def="NT-Misc">Misc</nt>
								
? 
*
(

								
*)?</rhs>
							

							

						</prod><prod id="NT-XMLDecl" num="23"><lhs>XMLDecl</lhs><rhs><nt def="NT-VersionInfo">VersionInfo</nt><nt def="NT-EncodingDecl">EncodingDecl</nt><nt def="NT-SDDecl">SDDecl</nt><nt def="NT-S">S</nt>&#x27;&lt;?xml&#x27; 

								
? 
? 
? &#x27;?&gt;&#x27;</rhs>
							

							

						</prod><prod id="NT-VersionInfo" num="24"><lhs>VersionInfo</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-Eq">Eq</nt><nt def="NT-VersionNum">VersionNum</nt><nt def="NT-VersionNum">VersionNum</nt>
								
 &#x27;version&#x27; 

(&quot;&#x27;&quot; 
 &quot;&#x27;&quot; | &#x27;&quot;&#x27; 

&#x27;&quot;&#x27;)</rhs>
							

							

						</prod><prod id="NT-Eq" num="25"><lhs>Eq</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-S">S</nt>
								
? &#x27;=&#x27; 
?</rhs>
							

							

						</prod><prod id="NT-VersionNum" num="26"><com diff="chg"><loc href="E10" role="erratumref" /></com><lhs>VersionNum</lhs><rhs diff="chg">&#x27;1.&#x27; [0-9]+</rhs>
							

							

							

						</prod><prod id="NT-Misc" num="27"><lhs>Misc</lhs><rhs><nt def="NT-Comment">Comment</nt><nt def="NT-PI">PI</nt><nt def="NT-S">S</nt>
								
 | 

| 

							</rhs>
							

							

						</prod>
						

						

						

						

						

						

					</prodgroup>
					

					

				</scrap><scrap id="dtd" lang="ebnf"><head>Document Type Definition</head><prodgroup pcw2="6" pcw4="17.5" pcw5="9"><prod id="NT-doctypedecl" num="28"><lhs>doctypedecl</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt><nt def="NT-ExternalID">ExternalID</nt><nt def="NT-S">S</nt><nt def="NT-intSubset">intSubset</nt><nt def="NT-S">S</nt>&#x27;&lt;!DOCTYPE&#x27; 

								

(

								
)? 
?
(&#x27;[&#x27; 
 &#x27;]&#x27; 
?)? &#x27;&gt;&#x27;</rhs><vc def="vc-roottype" /><wfc def="ExtSubset" />
							

							

							

							

						</prod><prod id="NT-DeclSep" num="28a"><lhs>DeclSep</lhs><rhs><nt def="NT-PEReference">PEReference</nt><nt def="NT-S">S</nt>
								
 | 

							</rhs><wfc def="PE-between-Decls" />
							

							

							

						</prod><prod id="NT-intSubset" num="28b"><lhs>intSubset</lhs><rhs><nt def="NT-markupdecl">markupdecl</nt><nt def="NT-DeclSep">DeclSep</nt>(
 | 
)*</rhs>
							

							

						</prod><prod id="NT-markupdecl" num="29"><lhs>markupdecl</lhs><rhs><nt def="NT-elementdecl">elementdecl</nt><nt def="NT-AttlistDecl">AttlistDecl</nt><nt def="NT-EntityDecl">EntityDecl</nt><nt def="NT-NotationDecl">NotationDecl</nt><nt def="NT-PI">PI</nt><nt def="NT-Comment">Comment</nt>
								
 | 
 | 

| 
 | 
 | 

							</rhs><vc def="vc-PEinMarkupDecl" /><wfc def="wfc-PEinInternalSubset" />
							

							

							

							

						</prod>
						

						

						

						

					</prodgroup>
					

					

				</scrap><scrap id="ext-Subset" lang="ebnf"><head>External Subset</head><prodgroup pcw2="6" pcw4="17.5" pcw5="9"><prod id="NT-extSubset" num="30"><lhs>extSubset</lhs><rhs><nt def="NT-TextDecl">TextDecl</nt><nt def="NT-extSubsetDecl">extSubsetDecl</nt>
								
? 

							</rhs>
							

							

						</prod><prod id="NT-extSubsetDecl" num="31"><lhs>extSubsetDecl</lhs><rhs><nt def="NT-markupdecl">markupdecl</nt><nt def="NT-conditionalSect">conditionalSect</nt><nt def="NT-DeclSep">DeclSep</nt>( 
 | 
 | 
)*</rhs>
							

							

						</prod>
						

						

					</prodgroup>
					

					

				</scrap><vcnote id="vc-roottype"><head>Root Element Type</head><p><nt def="NT-Name">Name</nt><rfc2119>MUST</rfc2119><termref def="dt-root">root element</termref>The 

in the document type declaration 
 match the element type of the 
.</p>
					

					

				</vcnote><vcnote id="vc-PEinMarkupDecl"><head>Proper Declaration/PE Nesting</head><p><nt def="NT-markupdecl">markupdecl</nt><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><termref def="dt-repltext">replacement text</termref><termref def="dt-PERef">parameter-entity
reference</termref>Parameter-entity 

						
 be properly nested with markup declarations. That is to say, if either
the first character or the last character of a markup declaration (

above) is contained in the replacement text for a 
, both 
 be contained in the same replacement text.</p>
					

					

				</vcnote><wfcnote id="wfc-PEinInternalSubset"><head>PEs in Internal Subset</head><p><rfc2119>MUST NOT</rfc2119><termref def="dt-PERef">parameter-entity references</termref>In
the internal DTD subset, 

						
 occur within markup declarations; they may occur where markup declarations can occur.
(This does not apply to references that occur in external parameter entities
or to the external subset.)</p>
					

					

				</wfcnote><wfcnote id="ExtSubset"><head>External Subset</head><p><nt def="NT-extSubset">extSubset</nt><rfc2119>MUST</rfc2119>The external subset, if any, 
 match the production for 
.</p>
					

					

				</wfcnote><wfcnote id="PE-between-Decls"><head>PE Between Declarations</head><p><nt def="NT-DeclSep">DeclSep</nt><nt def="NT-extSubsetDecl">extSubsetDecl</nt><rfc2119>MUST</rfc2119>The replacement text of a parameter entity reference
in a 

						
 match the production 
.</p>
					

					

				</wfcnote>
				

				

				

				

				

				

				

				

				

				
				

				

				
				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

			</div2><div2 id="sec-rmd"><eg>&lt;?xml version=&quot;1.0&quot; standalone=&#x27;yes&#x27;?&gt;</eg><head>Standalone Document Declaration</head><p><termdef id="dt-extmkpdecl" term="External Markup Declaration"><term>external
markup declaration</term>An 
 is defined as a markup declaration occurring in
the external subset or in a parameter entity (external or internal, the latter
being included because non-validating processors are not required to read
them).</termdef><termref def="dt-xml-proc">XML processor</termref><termref def="dt-docent">document
entity</termref>Markup declarations can affect the content of the document, as passed from
an 
 to an application; examples
are attribute defaults and entity declarations. The standalone document declaration,
which may appear as a component of the XML declaration, signals whether or
not there are such declarations which appear external to the 

or in parameter entities. 

				</p><p><attval>yes</attval><attval>no</attval><emph>declarations</emph><emph>entities</emph><termref def="dt-extmkpdecl">external markup declarations</termref>In a standalone document declaration, the value 
 indicates
that there are no 
 which
affect the information passed from the XML processor to the application. The
value 
 indicates that there are or may be such external
markup declarations. Note that the standalone document declaration only denotes
the presence of external 
; the presence, in a document,
of references to external 
, when those entities are internally
declared, does not change its standalone status.</p><p><attval>no</attval>If there are no external markup declarations, the standalone document declaration
has no meaning. If there are external markup declarations but there is no
standalone document declaration, the value 
 is assumed.</p><p><code>standalone=&quot;no&quot;</code>Any XML document for which 
 holds can be converted
algorithmically to a standalone document, which may be desirable for some
network delivery applications.</p><p>An example XML declaration with a standalone document declaration:</p><scrap id="fulldtd" lang="ebnf"><head>Standalone Document Declaration</head><prodgroup pcw2="4" pcw4="19.5" pcw5="9"><prod id="NT-SDDecl" num="32"><lhs>SDDecl</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-Eq">Eq</nt>
								
 &#x27;standalone&#x27; 

((&quot;&#x27;&quot; (&#x27;yes&#x27; | &#x27;no&#x27;) &quot;&#x27;&quot;) | (&#x27;&quot;&#x27; (&#x27;yes&#x27; | &#x27;no&#x27;) &#x27;&quot;&#x27;)) </rhs><vc def="vc-check-rmd" />
							

							

							

						</prod>
						

					</prodgroup>
					

					

				</scrap><vcnote id="vc-check-rmd"><head>Standalone Document Declaration</head><p><attval>no</attval><rfc2119>MUST</rfc2119>The
standalone document declaration 
 have the value 
 if
any external markup declarations contain declarations of:</p><ulist><item><p><termref def="dt-default">default</termref>attributes with 
 values,
if elements to which these attributes apply appear in the document without
specifications of values for these attributes, or</p>
							

						</item><item><p><code>amp</code><code>lt</code><code>gt</code><code>apos</code><code>quot</code><termref def="dt-entref">references</termref>entities (other than 
, 
, 
, 
, 
), if 

to those entities appear in the document, or</p>
							

						</item><item><p><titleref href="#AVNormalize">normalization</titleref>attributes with
tokenized types, where the
attribute appears in the document with a value such that


will produce a different value from that which would be produced
in the absence of the declaration, or</p>
							

						</item><item><p><termref def="dt-elemcontent">element content</termref>element types with 
,
if white space occurs directly within any instance of those types.</p>
							

						</item>
						

						

						

						

					</ulist>
					

					

					

				</vcnote>
				

				

				

				

				

				

				

				

				

			</div2><div2 id="sec-white-space"><eg><![CDATA[<!ATTLIST poem  xml:space (default|preserve) 'preserve'>]]>

&lt;!ATTLIST pre xml:space (preserve) #FIXED &#x27;preserve&#x27;&gt;</eg><head>White Space Handling</head><p><quote>white space</quote><quote>significant</quote>In editing XML documents, it is often convenient to use 

(spaces, tabs, and blank lines)
to set apart the markup for greater readability. Such white space is typically
not intended for inclusion in the delivered version of the document. On the
other hand, 
 white space that should be preserved
in the delivered version is common, for example in poetry and source code.</p><p><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><termref def="dt-xml-proc">XML processor</termref><termref def="dt-validating"> validating XML processor</termref><termref def="dt-elemcontent">element content</termref>An 

					
 always pass
all characters in a document that are not markup through to the application.
A 

					
 also
inform the application which of these characters constitute white space appearing
in 
.</p><p><att>xml:space</att><attval>default</attval><attval>preserve</attval><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><termref def="dt-attr">attribute</termref><termref def="dt-attdecl">declared</termref><termref def="dt-enumerated">enumerated
type</termref>A special 
 named 
 may be attached to an element to signal an intention that in that element,
white space should be preserved by applications. In valid documents, this
attribute, like any other, 
 be 

if it is used. When declared, it 
 be given as an 
 whose values
are one or both of 
 and 
.
For example:</p><p><att>xml:space</att><att>xml:space</att><attval>default</attval><attval>preserve</attval><attval>default</attval><attval>preserve</attval><rfc2119>MAY</rfc2119><rfc2119>MAY</rfc2119>The value 
 signals that applications&#x27; default white-space
processing modes are acceptable for this element; the value 

indicates the intent that applications preserve all the white space. This
declared intent is considered to apply to all elements within the content
of the element where it is specified, unless overridden with
another instance of the 
 attribute. This specification does not give meaning to any value of 
 other than 
 and 
. It is an error for other values to be specified; the XML processor 
 report the error or 
 recover by ignoring the attribute specification or by reporting the (erroneous) value to the application. Applications may ignore or reject erroneous values.</p><p><termref def="dt-root">root element</termref>The 
 of any document is considered
to have signaled no intentions as regards application space handling, unless
it provides a value for this attribute or the attribute is declared with a
default value.</p>
				

				

				

				

				

				

				

			</div2><div2 id="sec-line-ends"><head>End-of-Line Handling</head><p><termref def="dt-parsedent">parsed entities</termref>XML 
 are often stored
in computer files which, for editing convenience, are organized into lines.
These lines are typically separated by some combination of the characters
CARRIAGE RETURN (#xD) and LINE FEED (#xA).</p><p><rfc2119>MUST</rfc2119><termref def="dt-app">applications</termref><termref def="dt-xml-proc">XML
processor</termref>To
simplify the tasks of 
, the


					
 behave as if it normalized all line breaks in external parsed
entities (including the document entity) on input, before parsing, by translating
both the two-character sequence #xD #xA and any #xD that is not followed by
#xA to a single #xA character.</p>
				

				

				

			</div2><div2 id="sec-lang-tag"><eg>&lt;p xml:lang=&quot;en&quot;&gt;The quick brown fox jumps over the lazy dog.&lt;/p&gt;
&lt;p xml:lang=&quot;en-GB&quot;&gt;What colour is it?&lt;/p&gt;
&lt;p xml:lang=&quot;en-US&quot;&gt;What color is it?&lt;/p&gt;
&lt;sp who=&quot;Faust&quot; desc=&#x27;leise&#x27; xml:lang=&quot;de&quot;&gt;
  &lt;l&gt;Habe nun, ach! Philosophie,&lt;/l&gt;
  &lt;l&gt;Juristerei, und Medizin&lt;/l&gt;
  &lt;l&gt;und leider auch Theologie&lt;/l&gt;
  &lt;l&gt;durchaus studiert mit heißem Bemüh&#x27;n.&lt;/l&gt;
&lt;/sp&gt;</eg><eg>xml:lang CDATA #IMPLIED</eg><eg>&lt;!ATTLIST poem   xml:lang CDATA &#x27;fr&#x27;&gt;
&lt;!ATTLIST gloss  xml:lang CDATA &#x27;en&#x27;&gt;
&lt;!ATTLIST note   xml:lang CDATA &#x27;en&#x27;&gt;</eg><head>Language Identification</head><note><p><att>xml:lang</att>Language information may also be provided by external transport protocols (e.g. HTTP or
  MIME). When available, this information may be used by XML applications, but the more local
  information provided by 
 should be considered to override it.
</p>
					

				</note><p><att>xml:lang</att><bibref ref="RFC1766" /><phrase diff="del">, or its successor</phrase><rfc2119>MUST</rfc2119><termref def="dt-attr">attribute</termref><termref def="dt-attdecl">declared</termref><titleref>Tags
for the Identification of Languages</titleref>In document processing, it is often useful to identify the natural or formal
language in which the content is written. A special 

named 
 may be inserted in documents to specify the language
used in the contents and attribute values of any element in an XML document.
In valid documents, this attribute, like any other, 
 be 

if it is used. The
values of the attribute are language identifiers as defined by 
, 
; in addition, the empty string may be specified.</p><p>(Productions 33 through 38 have been removed.)</p><p>For example:</p><p><att>xml:lang</att><att>xml:lang</att><att>xml:lang</att><att>xml:lang</att><att>xml:lang</att><att>xml:lang</att>The language specified by 
 applies to the element where it is specified
		 (including the values of its attributes), and  to all elements in its content unless
     overridden with another instance of 
. In particular, the empty value of 
 is used on an element B to override
		 a specification of 
 on an enclosing element A, without specifying another language. Within B,
		 it is considered that there is no language information available, just as if 
 had not been specified
		 on B or any of its ancestors. Applications determine which of an element&#x27;s attribute values
     and which parts of its character content, if any, are treated as language-dependent values described by 
. </p><p><att>xml:lang</att>A simple declaration for 
 might take the form</p><p><att>xml:lang</att>but specific default values may also be given, if appropriate. In a collection
of French poems for English students, with glosses and notes in English, the 

attribute might be declared this way:</p>
				

				

				

				

				

				

				

				

				

				

				

				

				

			</div2><head>Documents</head><p><termdef id="dt-xml-doc" term="XML Document"><term>XML
document</term><termref def="dt-wellformed">well-formed</termref><termref def="dt-valid">valid</termref> A data object is an 
 if it is 
,
as defined in this specification. In addition, the XML document is

 if it meets certain further constraints.</termdef>
				

			</p><p><quote>root</quote><rfc2119>MUST</rfc2119><specref ref="wf-entities" /><termref def="dt-entity">entities</termref><termref def="dt-entref">refer</termref><termref def="dt-docent">document entity</termref>Each XML document has both a logical and a physical structure. Physically,
the document is composed of units called 
.
An entity may
				
 to other entities to
cause their inclusion in the document. A document begins in a 

or 
. Logically, the document
is composed of declarations, elements, comments, character references, and
processing instructions, all of which are indicated in the document by explicit
markup. The logical and physical structures 
 nest properly, as described
in 
.</p>
			

			

			

			

			

			

			

			

			

			

			

			

			

			

			

		</div1><div1 id="sec-logical-struct"><div2 id="sec-starttags"><eg>&lt;termdef id=&quot;dt-dog&quot; term=&quot;dog&quot;&gt;</eg><eg>&lt;/termdef&gt;</eg><eg>&lt;IMG align=&quot;left&quot;
 src=&quot;http://www.w3.org/Icons/WWW/w3c_home&quot; /&gt;
&lt;br&gt;&lt;/br&gt;
&lt;br/&gt;</eg><head>Start-Tags, End-Tags, and Empty-Element Tags</head><p><termdef id="dt-stag" term="Start-Tag"><term>start-tag</term>The beginning of every non-empty
XML element is marked by a 
.</termdef>
					

				</p><p><nt def="NT-Name">Name</nt><term>type</term><termdef id="dt-attr" term="Attribute"><nt def="NT-Name">Name</nt><nt def="NT-AttValue">AttValue</nt><term>attribute specifications</term> The 
-

pairs are referred to as the 
 of the
element</termdef><termdef id="dt-attrname" term="Attribute Name"><nt def="NT-Name">Name</nt><term>attribute name</term>with the 
 in each pair referred to as the 

					</termdef><termdef id="dt-attrval" term="Attribute Value"><code>&#x27;</code><code>&quot;</code><nt def="NT-AttValue">AttValue</nt><term>attribute value</term>the content of the 
 (the text between the 
 or 

delimiters) as the 
.</termdef>The 
 in the start- and end-tags gives the element&#x27;s 
. 
, 

and 
 Note
that the order of attribute specifications in a start-tag or empty-element
tag is not significant.</p><p>An example of a start-tag:</p><p><termdef id="dt-etag" term="End Tag"><rfc2119>MUST</rfc2119><term>end-tag</term>The end of every element that begins
with a start-tag 
 be marked by an 
 containing a name
that echoes the element&#x27;s type as given in the start-tag:</termdef>
					

				</p><p>An example of an end-tag:</p><p><termdef id="dt-content" term="Content"><term>content</term><termref def="dt-text">text</termref>The 

between the start-tag and end-tag is called the element&#x27;s 
:</termdef>
					

				</p><p><termdef id="dt-empty" term="Empty"><nt def="NT-content">content</nt><term>empty</term>An element
with no 
 is said to be 
.</termdef><termdef id="dt-eetag" term="empty-element tag"><term>empty-element
tag</term>An 
 takes a special form:</termdef>
					
 The representation
of an empty element is either a start-tag immediately followed by an end-tag,
or an empty-element tag. 

				</p><p><kw>EMPTY</kw><rfc2119>SHOULD</rfc2119><rfc2119>SHOULD</rfc2119><termref def="dt-interop">For
interoperability</termref>Empty-element tags may be used for any element which has no content, whether
or not it is declared using the keyword 
. 
, the empty-element tag 

be used, and 
 only be used, for elements which are declared
EMPTY.</p><p>Examples of empty elements:</p><scrap lang="ebnf"><head>Start-tag</head><prodgroup pcw2="6" pcw4="15" pcw5="11.5"><prod id="NT-STag" num="40"><lhs>STag</lhs><rhs><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt><nt def="NT-Attribute">Attribute</nt><nt def="NT-S">S</nt>&#x27;&lt;&#x27; 
 (

								
)* 
? &#x27;&gt;&#x27;</rhs><wfc def="uniqattspec" />
							

							

							

						</prod><prod id="NT-Attribute" num="41"><lhs>Attribute</lhs><rhs><nt def="NT-Name">Name</nt><nt def="NT-Eq">Eq</nt><nt def="NT-AttValue">AttValue</nt>
								

								

								

							</rhs><vc def="ValueType" /><wfc def="NoExternalRefs" /><wfc def="CleanAttrVals" />
							

							

							

							

							

						</prod>
						

						

					</prodgroup>
					

					

				</scrap><scrap lang="ebnf"><head>End-tag</head><prodgroup pcw2="6" pcw4="15" pcw5="11.5"><prod id="NT-ETag" num="42"><lhs>ETag</lhs><rhs><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt>&#x27;&lt;/&#x27; 

								
?
&#x27;&gt;&#x27;</rhs>
							

							

						</prod>
						

					</prodgroup>
					

					

				</scrap><scrap lang="ebnf"><head>Content of Elements</head><prodgroup pcw2="6" pcw4="15" pcw5="11.5"><prod id="NT-content" num="43"><lhs>content</lhs><rhs><nt def="NT-CharData">CharData</nt><nt def="NT-element">element</nt><nt def="NT-Reference">Reference</nt><nt def="NT-CDSect">CDSect</nt><nt def="NT-PI">PI</nt><nt def="NT-Comment">Comment</nt><nt def="NT-CharData">CharData</nt>
								
? ((

| 
 | 

| 
 | 
) 
?)*</rhs>
							

							

						</prod>
						

					</prodgroup>
					

					

				</scrap><scrap lang="ebnf"><head>Tags for Empty Elements</head><prodgroup pcw2="6" pcw4="15" pcw5="11.5"><prod id="NT-EmptyElemTag" num="44"><lhs>EmptyElemTag</lhs><rhs><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt><nt def="NT-Attribute">Attribute</nt><nt def="NT-S">S</nt>&#x27;&lt;&#x27; 
 (

								
)* 
? &#x27;/&gt;&#x27;</rhs><wfc def="uniqattspec" />
							

							

							

						</prod>
						

					</prodgroup>
					

					

				</scrap><vcnote id="ValueType"><head>Attribute Value Type</head><p><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><specref ref="attdecls" />The attribute 

have been declared; the value 
 be of the type declared for it. (For attribute
types, see 
.)</p>
					

					

				</vcnote><wfcnote id="uniqattspec"><head>Unique Att Spec</head><p><rfc2119>MUST NOT</rfc2119>An attribute name

 appear more than once in the same start-tag or empty-element tag.</p>
					

					

				</wfcnote><wfcnote id="NoExternalRefs"><head>No External Entity References</head><p><rfc2119>MUST NOT</rfc2119>Attribute
values 
 contain direct or indirect entity references to external entities.</p>
					

					

				</wfcnote><wfcnote id="CleanAttrVals"><head><code>&lt;</code>No 
 in Attribute Values</head><p><code>&lt;</code><rfc2119>MUST NOT</rfc2119><termref def="dt-repltext">replacement text</termref>The 
 of any entity
referred to directly or indirectly in an attribute value 
 contain a 
.</p>
					

					

				</wfcnote>
				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

			</div2><div2 id="elemdecls"><div3 id="sec-element-content"><eg>&lt;!ELEMENT spec (front, body, back?)&gt;
&lt;!ELEMENT div1 (head, (p | list | note)*, div2*)&gt;
&lt;!ELEMENT dictionary-body (%div.mix; | %dict.mix;)*&gt;</eg><head>Element Content</head><p><nt def="NT-cp">cp</nt><termdef id="dt-elemcontent" term="Element content"><nt def="NT-S">S</nt><rfc2119>MUST</rfc2119><term>element content</term><termref def="dt-stag">type</termref><termref def="dt-parentchild">child</termref>An element 
 has 
 when elements
of that type 
 contain only 

elements (no character data), optionally separated by white space (characters
matching the nonterminal 
).</termdef><termdef id="dt-content-model" term="Content model"><term>content
model</term>In this case, the constraint includes a 
, a simple grammar governing the allowed types of the
child elements and the order in which they are allowed to appear.</termdef>
						

						

The grammar is built on content particles (
s), which
consist of names, choice lists of content particles, or sequence lists of
content particles:</p><p><code>+</code><code>*</code><code>?</code><nt def="NT-Name">Name</nt><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><termref def="dt-parentchild">child</termref><termref def="dt-elemcontent">element
content</termref><termref def="dt-elemcontent">element content</termref>where each 
 is the type of an element which
may appear as a 
. Any content
particle in a choice list may appear in the 
 at the location where the choice list appears in the grammar;
content particles occurring in a sequence list 
 each appear in the 
 in the order given in the list.
The optional character following a name or list governs whether the element
or the content particles in the list may occur one or more (
),
zero or more (
), or zero or one times (
). The
absence of such an operator means that the element or content particle 

appear exactly once. This syntax and meaning are identical to those used in
the productions in this specification.</p><p><specref ref="determinism" /><termref def="dt-compat">For
compatibility</termref>The content of an element matches a content model if and only if it is
possible to trace out a path through the content model, obeying the sequence,
choice, and repetition operators and matching each element in the content
against an element type in the content model. 
, it is an error if the content model
allows an element to match more than one occurrence of an element type in the
content model. For more information, see 
.</p><p>Examples of element-content models:</p><scrap lang="ebnf"><head>Element-content Models</head><prodgroup pcw2="5.5" pcw4="16" pcw5="11"><prod id="NT-children" num="47"><lhs>children</lhs><rhs><nt def="NT-choice">choice</nt><nt def="NT-seq">seq</nt>(
 | 
)
(&#x27;?&#x27; | &#x27;*&#x27; | &#x27;+&#x27;)?</rhs>
								

								

							</prod><prod id="NT-cp" num="48"><lhs>cp</lhs><rhs><nt def="NT-Name">Name</nt><nt def="NT-choice">choice</nt><nt def="NT-seq">seq</nt>(
 | 

| 
) (&#x27;?&#x27; | &#x27;*&#x27; | &#x27;+&#x27;)?</rhs>
								

								

							</prod><prod id="NT-choice" num="49"><lhs>choice</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-cp">cp</nt><nt def="NT-S">S</nt><nt def="NT-S">S</nt><nt def="NT-cp">cp</nt><nt def="NT-S">S</nt>&#x27;(&#x27; 
? 
 ( 
? &#x27;|&#x27; 
? 
 )+ 
? &#x27;)&#x27;</rhs><vc def="vc-PEinGroup" />
								

								

								

							</prod><prod id="NT-seq" num="50"><lhs>seq</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-cp">cp</nt><nt def="NT-S">S</nt><nt def="NT-S">S</nt><nt def="NT-cp">cp</nt><nt def="NT-S">S</nt>&#x27;(&#x27; 
? 
 ( 
? &#x27;,&#x27; 
? 
 )* 
? &#x27;)&#x27;</rhs><vc def="vc-PEinGroup" />
								

								

								

							</prod>
							

							

							

							

						</prodgroup>
						

						

					</scrap><vcnote id="vc-PEinGroup"><head>Proper Group/PE Nesting</head><p><nt def="NT-choice">choice</nt><nt def="NT-seq">seq</nt><nt def="NT-Mixed">Mixed</nt><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><termref def="dt-repltext">replacement text</termref><termref def="dt-PERef">parameter
entity</termref>Parameter-entity 

							
 be properly nested with parenthesized
groups. That is to say, if either of the opening or closing parentheses in
a 
, 
, or 

construct is contained in the replacement text for a 
, both 
 be contained in the same replacement text.</p><p><code>|</code><code>,</code><nt def="NT-choice">choice</nt><nt def="NT-seq">seq</nt><nt def="NT-Mixed">Mixed</nt><rfc2119>SHOULD</rfc2119><rfc2119>SHOULD</rfc2119><termref def="dt-interop">For interoperability</termref>
							
, if a parameter-entity reference
appears in a 
, 
, or 
 construct, its replacement text 
 contain at
least one non-blank character, and neither the first nor last non-blank character
of the replacement text 
 be a connector (
 or 
).</p>
						

						

						

					</vcnote>
					

					

					

					

					

					

					

					

					

					

				</div3><div3 id="sec-mixed-content"><eg>&lt;!ELEMENT p (#PCDATA|a|ul|b|i|em)*&gt;
&lt;!ELEMENT p (#PCDATA | %font; | %phrase; | %special; | %form;)* &gt;
&lt;!ELEMENT b (#PCDATA)&gt;</eg><head>Mixed Content</head><p><termdef id="dt-mixed" term="Mixed Content"><term>mixed content</term><termref def="dt-stag">type</termref><termref def="dt-parentchild">child</termref>An element 

has 
 when elements of that type may contain character
data, optionally interspersed with 

elements.</termdef>
						
 In this case, the types of the child elements may be constrained,
but not their order or their number of occurrences:</p><p><kw>#PCDATA</kw><nt def="NT-Name">Name</nt><quote>parsed
character data.</quote>where the 
s give the types of elements that
may appear as children. The
keyword 
 derives historically from the term 

					</p><p>Examples of mixed content declarations:</p><scrap lang="ebnf"><head>Mixed-content Declaration</head><prodgroup pcw2="5.5" pcw4="16" pcw5="11"><prod id="NT-Mixed" num="51"><lhs>Mixed</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-S">S</nt><nt def="NT-S">S</nt><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt>&#x27;(&#x27; 
? &#x27;#PCDATA&#x27; (
?
&#x27;|&#x27; 
? 
)* 
?
&#x27;)*&#x27; </rhs><rhs><nt def="NT-S">S</nt><nt def="NT-S">S</nt>| &#x27;(&#x27; 
? &#x27;#PCDATA&#x27; 
? &#x27;)&#x27; </rhs><vc def="vc-PEinGroup" /><vc def="vc-MixedChildrenUnique" />
								

								

								

								

								

							</prod>
							

						</prodgroup>
						

						

					</scrap><vcnote id="vc-MixedChildrenUnique"><head>No Duplicate Types</head><p><rfc2119>MUST NOT</rfc2119>The
same name 
 appear more than once in a single mixed-content declaration.</p>
						

						

					</vcnote>
					

					

					

					

					

					

					

				</div3><eg>&lt;!ELEMENT br EMPTY&gt;
&lt;!ELEMENT p (#PCDATA|emph)* &gt;
&lt;!ELEMENT %name.para; %content.para; &gt;
&lt;!ELEMENT container ANY&gt;</eg><head>Element Type Declarations</head><p><termref def="dt-element">element</termref><termref def="dt-xml-doc">XML document</termref><termref def="dt-valid">validation</termref><termref def="dt-content">content</termref>The 
 structure of an 
 may, for 

purposes, be constrained using element type and attribute-list declarations.
An element type declaration constrains the element&#x27;s 
.</p><p><rfc2119>MAY</rfc2119><termref def="dt-parentchild">children</termref>Element type declarations often constrain which element types can appear
as 
 of the element. At user
option, an XML processor 
 issue a warning when a declaration mentions an
element type for which no declaration is provided, but this is not an error.</p><p><termdef id="dt-eldecl" term="Element Type declaration"><term>element
type declaration</term>An 
 takes the form:</termdef>
					

				</p><p><nt def="NT-Name">Name</nt>where the 
 gives the element type being declared.</p><p>Examples of element type declarations:</p><scrap lang="ebnf"><head>Element Type Declaration</head><prodgroup pcw2="5.5" pcw4="18" pcw5="9"><prod id="NT-elementdecl" num="45"><lhs>elementdecl</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt><nt def="NT-contentspec">contentspec</nt><nt def="NT-S">S</nt>&#x27;&lt;!ELEMENT&#x27; 

								

								

								

								
?
&#x27;&gt;&#x27;</rhs><vc def="EDUnique" />
							

							

							

						</prod><prod id="NT-contentspec" num="46"><lhs>contentspec</lhs><rhs><nt def="NT-Mixed">Mixed</nt><nt def="NT-children">children</nt>&#x27;EMPTY&#x27; | &#x27;ANY&#x27; | 

| 

							</rhs>
							

							

						</prod>
						

						

					</prodgroup>
					

					

				</scrap><vcnote id="EDUnique"><head>Unique Element Type Declaration</head><p><rfc2119>MUST NOT</rfc2119>An element type 
 be declared more than once.</p>
					

					

				</vcnote>
				

				

				

				

				

				

				

				

				

				

				

			</div2><div2 id="attdecls"><div3 id="sec-attribute-types"><head>Attribute Types</head><p><specref ref="AVNormalize" />XML attribute types are of three kinds: a string type, a set of tokenized
types, and enumerated types. The string type may take any literal string as
a value; the tokenized types are more constrained.
The validity constraints noted in the grammar are applied after the attribute
value has been normalized as described in 
.</p><p><rfc2119>MUST</rfc2119><termdef id="dt-enumerated" term="Enumerated Attribute
Values"><term>Enumerated attributes</term>
							

							have a list of allowed values in their declaration
						</termdef>
						
. They 
 take one of those values.  There are two kinds of enumerated attribute types:</p><p><kw>NOTATION</kw><termref def="dt-notation">notation</termref>A 
 attribute identifies a 
,
declared in the DTD with associated system and/or public identifiers, to be
used in interpreting the element to which the attribute is attached.</p><p><nt def="NT-Nmtoken">Nmtoken</nt><rfc2119>SHOULD NOT</rfc2119><termref def="dt-interop">For interoperability,</termref>
						
 the same 

						
 occur more than once in the enumerated
attribute types of a single element type.</p><scrap lang="ebnf"><head>Attribute Types</head><prodgroup pcw4="14" pcw5="11.5"><prod id="NT-AttType" num="54"><lhs>AttType</lhs><rhs><nt def="NT-StringType">StringType</nt><nt def="NT-TokenizedType">TokenizedType</nt><nt def="NT-EnumeratedType">EnumeratedType</nt>
									
 | 

| 

								</rhs>
								

								

							</prod><prod id="NT-StringType" num="55"><lhs>StringType</lhs><rhs>&#x27;CDATA&#x27;</rhs>
								

								

							</prod><prod id="NT-TokenizedType" num="56"><lhs>TokenizedType</lhs><rhs>&#x27;ID&#x27;</rhs><rhs>| &#x27;IDREF&#x27;</rhs><rhs>| &#x27;IDREFS&#x27;</rhs><rhs>| &#x27;ENTITY&#x27;</rhs><rhs>| &#x27;ENTITIES&#x27;</rhs><rhs>| &#x27;NMTOKEN&#x27;</rhs><rhs>| &#x27;NMTOKENS&#x27;</rhs><vc def="id" /><vc def="one-id-per-el" /><vc def="id-default" /><vc def="idref" /><vc def="idref" /><vc def="entname" /><vc def="entname" /><vc def="nmtok" /><vc def="nmtok" />
								

								

								

								

								

								

								

								

								

								

								

								

								

								

								

								

								

							</prod>
							

							

							

						</prodgroup>
						

						

					</scrap><scrap lang="ebnf"><head>Enumerated Attribute Types</head><prod id="NT-EnumeratedType" num="57"><lhs>EnumeratedType</lhs><rhs><nt def="NT-NotationType">NotationType</nt><nt def="NT-Enumeration">Enumeration</nt>
								

| 

							</rhs>
							

							

						</prod><prod id="NT-NotationType" num="58"><lhs>NotationType</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-S">S</nt><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt><nt def="NT-S">S</nt><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt>&#x27;NOTATION&#x27; 
 &#x27;(&#x27; 
? 
 (
? &#x27;|&#x27; 
? 
)* 
? &#x27;)&#x27; </rhs><vc def="notatn" /><vc def="OneNotationPer" /><vc def="NoNotationEmpty" /><vc def="NoDuplicateTokens" />
							

							

							

							

							

							

						</prod><prod id="NT-Enumeration" num="59"><lhs>Enumeration</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-Nmtoken">Nmtoken</nt><nt def="NT-S">S</nt><nt def="NT-S">S</nt><nt def="NT-Nmtoken">Nmtoken</nt><nt def="NT-S">S</nt>&#x27;(&#x27; 
? 

(
? &#x27;|&#x27; 
? 
)* 
? &#x27;)&#x27;</rhs><vc def="enum" /><vc def="NoDuplicateTokens" />
							

							

							

							

						</prod>
						

						

						

						

					</scrap><vcnote id="id"><head>ID</head><p><kw>ID</kw><nt def="NT-Name">Name</nt><rfc2119>MUST</rfc2119><rfc2119>MUST NOT</rfc2119><rfc2119>MUST</rfc2119>Values of type 

							
 match the 
 production. A name 
 appear more than once
in an XML document as a value of this type; i.e., ID values 
 uniquely
identify the elements which bear them.</p>
						

						

					</vcnote><vcnote id="one-id-per-el"><head>One ID per Element Type</head><p><rfc2119>MUST NOT</rfc2119>An element type 
 have more than one ID attribute specified.</p>
						

						

					</vcnote><vcnote id="id-default"><head>ID Attribute Default</head><p><kw>#IMPLIED</kw><kw>#REQUIRED</kw><rfc2119>MUST</rfc2119>An ID attribute

 have a declared default of 
 or 
.</p>
						

						

					</vcnote><vcnote id="idref"><head>IDREF</head><p><kw>IDREF</kw><kw>IDREFS</kw><kw>IDREF</kw><nt def="NT-Name">Name</nt><nt def="NT-Names">Names</nt><nt def="NT-Name">Name</nt><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119>Values of type 

							

match the 
 production, and values of type 

							
 match 
; each 

							
 match the value of an ID attribute on some element in the XML document;
i.e. 
 values 
 match the value of some ID attribute.</p>
						

						

					</vcnote><vcnote id="entname"><head>Entity Name</head><p><kw>ENTITY</kw><kw>ENTITIES</kw><nt def="NT-Name">Name</nt><nt def="NT-Names">Names</nt><nt def="NT-Name">Name</nt><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><termref def="dt-unparsed">unparsed entity</termref><termref def="dt-doctype">DTD</termref>Values of type 

							
 match the 
 production, values of type 

							
 match 
; each 

							
 match the name of an 

declared in the 
.</p>
						

						

					</vcnote><vcnote id="nmtok"><head>Name Token</head><p><kw>NMTOKEN</kw><kw>NMTOKENS</kw><nt def="NT-Nmtoken">Nmtoken</nt><nt def="NT-Nmtokens">Nmtokens</nt><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119>Values of type 

							
 match the 
 production; values of type 

							
 match 
.</p>
						

						

					</vcnote><vcnote id="notatn"><head>Notation Attributes</head><p><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><titleref href="#Notations">notation</titleref>Values of this type

 match one of the 
 names
included in the declaration; all notation names in the declaration 
 be
declared.</p>
						

						

					</vcnote><vcnote id="OneNotationPer"><head>One Notation Per Element Type</head><p><kw>NOTATION</kw><rfc2119>MUST NOT</rfc2119>An element type 
 have more than one 

attribute specified.</p>
						

						

					</vcnote><vcnote id="NoNotationEmpty"><head>No Notation on Empty Element</head><p><kw>NOTATION</kw><kw>EMPTY</kw><rfc2119>MUST NOT</rfc2119><termref def="dt-compat">For compatibility</termref>
							
,
an attribute of type 

							
 be declared on an element
declared 
.</p>
						

						

					</vcnote><vcnote id="NoDuplicateTokens"><head>No Duplicate Tokens</head><p><nt def="NT-NotationType">NotationType</nt><nt def="NT-Nmtoken">NmToken</nt><nt def="NT-Enumeration">Enumeration</nt><rfc2119>MUST</rfc2119>The notation names in a single 

attribute declaration, as well as the 
s in a single

 attribute declaration, 
 all be distinct.</p>
						

						

					</vcnote><vcnote id="enum"><head>Enumeration</head><p><nt def="NT-Nmtoken">Nmtoken</nt><rfc2119>MUST</rfc2119>Values of this type 
 match
one of the 
 tokens in the declaration.</p>
						

						

					</vcnote>
					

					

					

					

					

					

					

					

					

					

					

					

					

					

					

					

					

					

					

				</div3><div3 id="sec-attr-defaults"><eg>&lt;!ATTLIST termdef
          id      ID      #REQUIRED
          name    CDATA   #IMPLIED&gt;
&lt;!ATTLIST list
          type    (bullets|ordered|glossary)  &quot;ordered&quot;&gt;
&lt;!ATTLIST form
          method  CDATA   #FIXED &quot;POST&quot;&gt;</eg><head>Attribute Defaults</head><p><rfc2119>REQUIRED</rfc2119><termref def="dt-attdecl">attribute declaration</termref>An 
 provides information
on whether the attribute&#x27;s presence is 
, and if not, how an XML processor
is to react if a declared attribute is absent in a document.</p><p><kw>#REQUIRED</kw><kw>#IMPLIED</kw><rfc2119>MUST</rfc2119><termdef id="dt-default" term="Attribute Default"><kw>#REQUIRED</kw><kw>#IMPLIED</kw><kw>#FIXED</kw><nt def="NT-AttValue">AttValue</nt><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><term>default</term>If
the declaration is neither 
 nor 
, then
the 
 value contains the declared 

value; the 
 keyword states that the attribute 
 always have
the default value.
When an XML processor encounters
an element
without a specification for an attribute for which it has read a default
value declaration, it 
 report the attribute with the declared default
value to the application.</termdef>In an attribute declaration, 
 means that the attribute

 always be provided, 
 that no default value is provided.


						

					</p><p>Examples of attribute-list declarations:</p><scrap lang="ebnf"><head>Attribute Defaults</head><prodgroup pcw4="14" pcw5="11.5"><prod id="NT-DefaultDecl" num="60"><lhs>DefaultDecl</lhs><rhs>&#x27;#REQUIRED&#x27; | &#x27;#IMPLIED&#x27; </rhs><rhs><nt def="NT-S">S</nt><nt def="NT-AttValue">AttValue</nt>| ((&#x27;#FIXED&#x27; 
)? 
)</rhs><vc def="RequiredAttr" /><vc def="defattrvalid" /><vc def="FixedAttr" /><wfc def="CleanAttrVals" /><wfc def="NoExternalRefs" />
								

								

								

								

								

								

								

								

							</prod>
							

						</prodgroup>
						

						

					</scrap><vcnote id="RequiredAttr"><head>Required Attribute</head><p><kw>#REQUIRED</kw><rfc2119>MUST</rfc2119>If the default
declaration is the keyword 
, then the attribute 
 be
specified for all elements of the type in the attribute-list declaration.</p>
						

						

					</vcnote><vcnote id="defattrvalid"><head>Attribute Default Value Syntactically Correct</head><p><rfc2119>MUST</rfc2119>The declared default value 
 meet the syntactic
constraints of the declared attribute type. That is, the default value of an attribute:
						</p><p>Note that only the
syntactic constraints of the type are required here; other constraints (e.g.
that the value be the name of a declared unparsed entity, for an attribute of
type ENTITY) will be reported by a validating
parser only if an element without a specification for this attribute
actually occurs.</p><ulist><item><p><nt def="NT-Name">Name</nt>
									of type IDREF or ENTITY must match the 
 production;</p>
								

							</item><item><p><nt def="NT-Names">Names</nt>
									of type IDREFS or ENTITIES must match the 
 production;</p>
								

							</item><item><p><nt def="NT-Nmtoken">Nmtoken</nt>
									of type NMTOKEN must match the 
 production;</p>
								

							</item><item><p><nt def="NT-Nmtokens">Nmtokens</nt>
									of type NMTOKENS must match the 
 production;</p>
								

							</item><item><p><nt def="NT-EnumeratedType">enumerated type</nt><nt def="NT-NotationType">NOTATION</nt><nt def="NT-Enumeration">enumeration</nt>
									of an 
 (either a 
 type or an 
) must match one of the enumerated values.</p>
								

							</item>
							

							

							

							

							

						</ulist>
						

						

						

						

					</vcnote><vcnote id="FixedAttr"><head>Fixed Attribute Default</head><p><kw>#FIXED</kw><rfc2119>MUST</rfc2119>If an attribute
has a default value declared with the 
 keyword, instances of
that attribute 
 match the default value.</p>
						

						

					</vcnote>
					

					

					

					

					

					

					

					

					

				</div3><div3 id="AVNormalize"><eg>&lt;!ENTITY d &quot;&amp;#xD;&quot;&gt;
&lt;!ENTITY a &quot;&amp;#xA;&quot;&gt;
&lt;!ENTITY da &quot;&amp;#xD;&amp;#xA;&quot;&gt;</eg><head>Attribute-Value Normalization</head><olist><item><p><rfc2119>MUST</rfc2119><specref ref="sec-line-ends" />All line breaks 
 have been normalized on input to #xA as described
in 
, so the rest of this algorithm operates
on text normalized in this way.</p>
							

						</item><item><p>Begin with a normalized value consisting of the empty string.</p>
							

						</item><item><p>For each character, entity reference, or character reference in the
unnormalized attribute value, beginning with the first and continuing to the
last, do the following:</p><ulist><item><p>For a character reference, append the referenced character to the
normalized value.</p>
									

								</item><item><p>For an entity reference, recursively apply step 3 of this algorithm
to the replacement text of the entity.</p>
									

								</item><item><p>For a white space character (#x20, #xD, #xA, #x9), append a space
character (#x20) to the normalized value.</p>
									

								</item><item><p>For another character, append the character to the normalized value.</p>
									

								</item>
								

								

								

								

							</ulist>
							

							

						</item>
						

						

						

					</olist><p><rfc2119>MUST</rfc2119>Before the value of an attribute is passed to the application or checked
for validity, the XML processor 
 normalize the attribute value by applying
the algorithm below, or by using some other method such that the value passed
to the application is the same as that produced by the algorithm.</p><p><rfc2119>MUST</rfc2119>If the attribute type is not CDATA, then the XML processor 
 further
process the normalized attribute value by discarding any leading and trailing
space (#x20) characters, and by replacing sequences of space (#x20) characters
by a single space (#x20) character.</p><p>Note that if the unnormalized attribute value contains a character reference
to a white space character other than space (#x20), the normalized value contains
the referenced character itself (#xD, #xA or #x9). This contrasts with the
case where the unnormalized value contains a white space character (not a
reference), which is replaced with a space character (#x20) in the normalized
value and also contrasts with the case where the unnormalized value contains
an entity reference whose replacement text contains a white space character;
being recursively processed, the white space character is replaced with a
space character (#x20) in the normalized value.</p><p><kw>CDATA</kw><rfc2119>SHOULD</rfc2119>All attributes for which no declaration has been read 
 be treated
by a non-validating processor as if declared 
.</p><p><termref def="dt-attrval">attribute
value</termref><termref def="dt-entref">reference</termref>It is an error if an 
 contains a 
 to an
entity for which no declaration has been read.</p><p>Following are examples of attribute normalization. Given the following
declarations:</p><p><att>a</att><att>a</att><kw>NMTOKENS</kw><kw>CDATA</kw>the attribute specifications in the left column below would be normalized
to the character sequences of the middle column if the attribute 

is declared 
 and to those of the right columns if 

is declared 
.</p><p><att>a</att><kw>NMTOKENS</kw>Note that the last example is invalid (but well-formed) if 

is declared to be of type 
.</p><table border="1" frame="border"><tbody><tr><td><eg>a=&quot;

xyz&quot;</eg>
									

								</td><td><eg>x y z</eg>
									

								</td><td><eg>#x20 #x20 x y z</eg>
									

								</td>
								

								

								

							</tr><tr><td><eg>a=&quot;&amp;d;&amp;d;A&amp;a;&amp;#x20;&amp;a;B&amp;da;&quot;</eg>
									

								</td><td><eg>A #x20 B</eg>
									

								</td><td><eg>#x20 #x20 A #x20 #x20 #x20 B #x20 #x20</eg>
									

								</td>
								

								

								

							</tr><tr><td><eg>a=
&quot;&amp;#xd;&amp;#xd;A&amp;#xa;&amp;#xa;B&amp;#xd;&amp;#xa;&quot;</eg>
									

								</td><td><eg>#xD #xD A #xA #xA B #xD #xA</eg>
									

								</td><td><eg>#xD #xD A #xA #xA B #xD #xA</eg>
									

								</td>
								

								

								

							</tr>
							

							

							

						</tbody><thead><tr><th>Attribute specification</th><th>a is NMTOKENS</th><th>a is CDATA</th>
								

								

								

							</tr>
							

						</thead>
						

						

					</table>
					

					

					

					

					

					

					

					

					

					

					

					

				</div3><head>Attribute-List Declarations</head><p><rfc2119>MUST NOT</rfc2119><specref ref="sec-starttags" /><termref def="dt-attr">Attributes</termref><termref def="dt-element">elements</termref><termref def="dt-stag">start-tags</termref><termref def="dt-eetag">empty-element tags</termref>
					
 are used to associate name-value
pairs with 
. Attribute specifications

 appear outside of 
 and 
; thus, the productions used to
recognize them appear in 
. Attribute-list declarations
may be used:</p><p><termdef id="dt-attdecl" term="Attribute-List Declaration"><term>Attribute-list
declarations</term>
						
 specify the name, data type, and default value (if any)
of each attribute associated with a given element type:</termdef>
					

				</p><p><nt def="NT-Name">Name</nt><nt def="NT-AttlistDecl">AttlistDecl</nt><nt def="NT-Name">Name</nt><nt def="NT-AttDef">AttDef</nt><rfc2119>MAY</rfc2119>The 
 in the 

rule is the type of an element. At user option, an XML processor 
 issue
a warning if attributes are declared for an element type not itself declared,
but this is not an error. The 
 in the 

rule is the name of the attribute.</p><p><nt def="NT-AttlistDecl">AttlistDecl</nt><rfc2119>MAY</rfc2119><termref def="dt-interop">For interoperability,</termref>When more than one 
 is provided
for a given element type, the contents of all those provided are merged. When
more than one definition is provided for the same attribute of a given element
type, the first declaration is binding and later declarations are ignored. 
 writers of DTDs may choose
to provide at most one attribute-list declaration for a given element type,
at most one attribute definition for a given attribute name in an attribute-list
declaration, and at least one attribute definition in each attribute-list
declaration. For interoperability, an XML processor 
 at user option
issue a warning when more than one attribute-list declaration is provided
for a given element type, or more than one attribute definition is provided
for a given attribute, but this is not an error.</p><scrap lang="ebnf"><head>Attribute-list Declaration</head><prod id="NT-AttlistDecl" num="52"><lhs>AttlistDecl</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-Name">Name</nt><nt def="NT-AttDef">AttDef</nt><nt def="NT-S">S</nt>&#x27;&lt;!ATTLIST&#x27; 

							

							
* 
? &#x27;&gt;&#x27;</rhs>
						

						

					</prod><prod id="NT-AttDef" num="53"><lhs>AttDef</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt><nt def="NT-AttType">AttType</nt><nt def="NT-S">S</nt><nt def="NT-DefaultDecl">DefaultDecl</nt>
							

							

							

							

							

							

						</rhs>
						

						

					</prod>
					

					

					

				</scrap><ulist><item><p>To define the set of attributes pertaining to a given element type.</p>
						

					</item><item><p>To establish type constraints for these attributes.</p>
						

					</item><item><p><termref def="dt-default">default values</termref>To provide 
 for
attributes.</p>
						

					</item>
					

					

					

				</ulist>
				

				

				

				

				

				

				

				

				

				

			</div2><div2 id="sec-condition-sect"><eg>&lt;!ENTITY % draft &#x27;INCLUDE&#x27; &gt;
&lt;!ENTITY % final &#x27;IGNORE&#x27; &gt;

&lt;![%draft;[
&lt;!ELEMENT book (comments*, title, body, supplements?)&gt;
]]&gt;
&lt;![%final;[
&lt;!ELEMENT book (title, body, supplements?)&gt;
]]&gt;</eg><head>Conditional Sections</head><p><termdef id="dt-cond-section" term="conditional section"><term>Conditional
sections</term><termref def="dt-doctype">document type
declaration external subset</termref>
						
 are portions of the 
 or
of external parameter entities which are included in, or excluded from,
the logical structure of the DTD based on the keyword which governs them.</termdef>
					

				</p><p>Like the internal and external DTD subsets, a conditional section may contain
one or more complete declarations, comments, processing instructions, or nested
conditional sections, intermingled with white space.</p><p><code>[</code><code>&lt;![</code><code>]]&gt;</code><kw>INCLUDE</kw><kw>IGNORE</kw><kw>INCLUDE</kw><kw>IGNORE</kw><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><rfc2119>NOT</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST NOT</rfc2119>If the keyword of the conditional section is 
, then the
contents of the conditional section 
 be processed as part of the DTD. If the keyword of
the conditional section is 
, then the contents of the conditional
section 
 
 be processed as part of the DTD.
If a conditional section with a keyword of 
 occurs within
a larger conditional section with a keyword of 
, both the outer
and the inner conditional sections 
 be ignored. The contents
of an ignored conditional section 
 be parsed by ignoring all characters after
the &quot;
&quot; following the keyword, except conditional section starts
&quot;
&quot; and ends &quot;
&quot;, until the matching conditional
section end is found. Parameter entity references 
 be recognized in this
process.</p><p><rfc2119>MUST</rfc2119>If the keyword of the conditional section is a parameter-entity reference,
the parameter entity 
 be replaced by its content before the processor
decides whether to include or ignore the conditional section.</p><p>An example:</p><scrap lang="ebnf"><head>Conditional Section</head><prodgroup pcw2="9" pcw4="14.5"><prod id="NT-conditionalSect" num="61"><lhs>conditionalSect</lhs><rhs><nt def="NT-includeSect">includeSect</nt><nt def="NT-ignoreSect">ignoreSect</nt>
								
 | 

							</rhs>
							

							

						</prod><prod id="NT-includeSect" num="62"><lhs>includeSect</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-S">S</nt><nt def="NT-extSubsetDecl">extSubsetDecl</nt>&#x27;&lt;![&#x27; 
? &#x27;INCLUDE&#x27; 
? &#x27;[&#x27; 

&#x27;]]&gt;&#x27; </rhs><vc def="condsec-nesting" />
							

							

							

						</prod><prod id="NT-ignoreSect" num="63"><lhs>ignoreSect</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-S">S</nt><nt def="NT-ignoreSectContents">ignoreSectContents</nt>&#x27;&lt;![&#x27; 
? &#x27;IGNORE&#x27; 
? &#x27;[&#x27; 
*
&#x27;]]&gt;&#x27;</rhs><vc def="condsec-nesting" />
							

							

							

						</prod><prod id="NT-ignoreSectContents" num="64"><lhs>ignoreSectContents</lhs><rhs><nt def="NT-Ignore">Ignore</nt><nt def="NT-ignoreSectContents">ignoreSectContents</nt><nt def="NT-Ignore">Ignore</nt>
								
 (&#x27;&lt;![&#x27; 
 &#x27;]]&gt;&#x27; 
)*</rhs>
							

							

						</prod><prod id="NT-Ignore" num="65"><lhs>Ignore</lhs><rhs><nt def="NT-Char">Char</nt><nt def="NT-Char">Char</nt><nt def="NT-Char">Char</nt>
								
* - (
*
(&#x27;&lt;![&#x27; | &#x27;]]&gt;&#x27;) 
*) </rhs>
							

							

						</prod>
						

						

						

						

						

					</prodgroup>
					

					

				</scrap><vcnote id="condsec-nesting"><head>Proper Conditional Section/PE Nesting</head><p><code>&lt;![</code><code>[</code><code>]]&gt;</code><rfc2119>MUST</rfc2119>If any of the &quot;
&quot;,
&quot;
&quot;, or &quot;
&quot; of a conditional section is contained
in the replacement text for a parameter-entity reference, all of them 

be contained in the same replacement text.</p>
					

					

				</vcnote>
				

				

				

				

				

				

				

				

				

			</div2><head>Logical Structures</head><p><termdef id="dt-element" term="Element"><quote>generic
identifier</quote><term>elements</term><termref def="dt-xml-doc">XML
document</termref><termref def="dt-stag">start-tags</termref><termref def="dt-etag">end-tags</termref><termref def="dt-empty">empty</termref><termref def="dt-eetag">empty-element tag</termref>Each 
 contains one or more 
, the boundaries
of which are either delimited by 

and 
, or, for 

elements, by an 
. Each
element has a type, identified by name, sometimes called its 
 (GI), and may have a set of attribute specifications.</termdef><termref def="dt-attrname">name</termref><termref def="dt-attrval">value</termref>
				

Each attribute specification has a 

and a 
.</p><p><code>((&#x27;X&#x27;|&#x27;x&#x27;)(&#x27;M&#x27;|&#x27;m&#x27;)(&#x27;L&#x27;|&#x27;l&#x27;))</code>This specification does not constrain the
			application semantics, use, or (beyond syntax)
names of the element types and attributes, except that names beginning with
a match to 
 are reserved for standardization
in this or future versions of this specification.</p><scrap lang="ebnf"><head>Element</head><prod id="NT-element" num="39"><lhs>element</lhs><rhs><nt def="NT-EmptyElemTag">EmptyElemTag</nt>
						

					</rhs><rhs><nt def="NT-STag">STag</nt><nt def="NT-content">content</nt><nt def="NT-ETag">ETag</nt>| 

						

						

					</rhs><vc def="elementvalid" /><wfc def="GIMatch" />
					

					

					

					

					

				</prod>
				

				

			</scrap><vcnote id="elementvalid"><head>Element Valid</head><olist><item><p><kw>EMPTY</kw><termref def="dt-content">content</termref>The declaration matches 
 and the element has no 
 (not even entity
references, comments, PIs or white space).</p>
						

					</item><item><p><nt def="NT-children">children</nt><nt def="NT-Misc">Misc</nt><nt def="NT-S">S</nt><nt def="NT-S">S</nt><termref def="dt-parentchild">child elements</termref>The declaration matches 
 and the
sequence of 
 belongs
to the language generated by the regular expression in the content model,
with optional white space, comments and
PIs (i.e. markup matching production [27] 
) between the
start-tag and the first child element, between child elements, or between
the last child element and the end-tag. Note that a CDATA section containing
only white space or a reference
to an entity whose replacement text is character references expanding to white
space do not
match the nonterminal 
, and
hence cannot appear in these positions; however, a
reference to an internal entity with a literal value consisting of character
references expanding to white space does match 
, since its
replacement text is the white space resulting from expansion of the character
references.</p>
						

					</item><item><p><nt def="NT-Mixed">Mixed</nt><termref def="dt-chardata">character data</termref><termref def="dt-cdsection">CDATA sections</termref><termref def="dt-comment">comments</termref><termref def="dt-pi">PIs</termref><termref def="dt-parentchild">child elements</termref>The declaration matches 
, and the content
(after replacing
any entity references with their replacement text) consists of


(including 
),

, 
 and 
 whose types match names in the
content model.</p>
						

					</item><item><p><kw>ANY</kw><termref def="dt-cdsection">CDATA
sections</termref><termref def="dt-comment">comments</termref><termref def="dt-pi">PIs</termref><termref def="dt-parentchild">child elements</termref>The declaration matches 
, and the content (after replacing
any entity references with their replacement text)
consists of character data, 
, 
, 

 and 

whose types have been declared.</p>
						

					</item>
					

					

					

					

				</olist><p><nt def="NT-elementdecl">elementdecl</nt><nt def="NT-Name">Name</nt>An element is valid
if there is a declaration matching 

where the 
 matches the element type, and one of
the following holds:</p>
				

				

				

			</vcnote><wfcnote id="GIMatch"><head>Element Type Match</head><p><nt def="NT-Name">Name</nt><rfc2119>MUST</rfc2119>The 

in an element&#x27;s end-tag 
 match the element type in the start-tag.</p>
				

				

			</wfcnote>
			

			

			

			

			

			

			

			

			

			

			

		</div1><div1 id="sec-physical-struct"><div2 id="sec-references"><eg>Type &lt;key&gt;less-than&lt;/key&gt; (&amp;#x3C;) to save options.
This document was prepared on &amp;docdate; and
is classified &amp;security-level;.</eg><eg>&lt;!-- declare the parameter entity &quot;ISOLat2&quot;... --&gt;
&lt;!ENTITY % ISOLat2
         SYSTEM &quot;http://www.xml.com/iso/isolat2-xml.entities&quot; &gt;
&lt;!-- ... now reference it. --&gt;
%ISOLat2;</eg><head>Character and Entity References</head><p><termdef id="dt-charref" term="Character Reference"><term>character
reference</term> A 
 refers to a specific character in the ISO/IEC 10646 character
set, for example one not directly accessible from available input devices.</termdef>
					

				</p><p><code>;</code><code>;</code><quote><code>&amp;#x</code>
						

					</quote><quote><code>&amp;#</code>
						

					</quote>If the character reference begins with 
,
the digits and letters up to the terminating 
 provide a hexadecimal
representation of the character&#x27;s code point in ISO/IEC 10646. If it begins
just with 
, the digits up to the terminating 

provide a decimal representation of the character&#x27;s code point.</p><p><termdef id="dt-entref" term="Entity Reference"><term>entity reference</term>An 

refers to the content of a named entity.</termdef><termdef id="dt-GERef" term="General Entity Reference"><code>&amp;</code><code>;</code>References to parsed general entities use
ampersand (
) and semicolon (
) as delimiters.</termdef><termdef id="dt-PERef" term="Parameter-entity reference"><code>%</code><code>;</code><term>Parameter-entity references</term>
						

use percent-sign (
) and semicolon (
) as delimiters.</termdef>
					

					

					

				</p><p>Examples of character and entity references:</p><p>Example of a parameter-entity reference:</p><scrap lang="ebnf"><head>Character Reference</head><prod id="NT-CharRef" num="66"><lhs>CharRef</lhs><rhs>&#x27;&amp;#&#x27; [0-9]+ &#x27;;&#x27; </rhs><rhs>| &#x27;&amp;#x&#x27; [0-9a-fA-F]+ &#x27;;&#x27;</rhs><wfc def="wf-Legalchar" />
						

						

						

						

					</prod>
					

					

				</scrap><scrap lang="ebnf"><head>Entity Reference</head><prod id="NT-Reference" num="67"><lhs>Reference</lhs><rhs><nt def="NT-EntityRef">EntityRef</nt><nt def="NT-CharRef">CharRef</nt>
							
 | 

						</rhs>
						

						

					</prod><prod id="NT-EntityRef" num="68"><lhs>EntityRef</lhs><rhs><nt def="NT-Name">Name</nt>&#x27;&amp;&#x27; 
 &#x27;;&#x27;</rhs><vc def="vc-entdeclared" /><wfc def="wf-entdeclared" /><wfc def="textent" /><wfc def="norecursion" />
						

						

						

						

						

						

					</prod><prod id="NT-PEReference" num="69"><lhs>PEReference</lhs><rhs><nt def="NT-Name">Name</nt>&#x27;%&#x27; 
 &#x27;;&#x27;</rhs><vc def="vc-entdeclared" /><wfc def="norecursion" /><wfc def="indtd" />
						

						

						

						

						

					</prod>
					

					

					

					

				</scrap><vcnote id="vc-entdeclared"><head>Entity Declared</head><p><code>amp</code><code>lt</code><code>gt</code><code>apos</code><code>quot</code><nt def="NT-Name">Name</nt><phrase diff="chg"><loc href="E08" role="erratumref" /><quote><code>standalone=&#x27;no&#x27;</code></quote>,
						if the document is not standalone (either 

						is specified or there is no standalone declaration), then</phrase><rfc2119>MUST</rfc2119><rfc2119>SHOULD</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><specref ref="sec-predefined-ent" /><termref def="dt-match">match</termref><titleref href="#sec-entity-decl">entity
declaration</titleref>In a document with an external subset or parameter  entity references

the 
 given in the entity reference 

						
 that in an 
. For interoperability, valid documents 
 declare
the entities 
, 
, 
, 
, 
, in the form specified in 
.
The declaration of a parameter entity 
 precede any reference to it. Similarly,
the declaration of a general entity 
 precede any attribute-list
declaration containing a default value with a direct or indirect reference
to that general entity.</p>
					

					

				</vcnote><wfcnote id="wf-Legalchar"><head>Legal Character</head><p><nt def="NT-Char">Char</nt><rfc2119>MUST</rfc2119>Characters referred
to using character references 
 match the production for 
.</p>
					

					

				</wfcnote><wfcnote id="wf-entdeclared"><head>Entity Declared</head><p><code>amp</code><code>lt</code><code>gt</code><code>apos</code><code>quot</code><nt def="NT-Name">Name</nt><quote><code>standalone=&#x27;yes&#x27;</code>
							

						</quote><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><termref def="dt-match">match</termref><titleref href="#sec-entity-decl">entity
declaration</titleref>In a document
without any DTD, a document with only an internal DTD subset which contains
no parameter entity references, or a document with 
, for
an entity reference that does not occur within the external subset or a parameter
entity, the 
 given in the entity reference 

						
 that in an 
 that does not occur within the external subset or a
parameter entity, except that well-formed documents need not declare
any of the following entities: 
, 
, 
, 
, 
. The
declaration of a general entity 
 precede any reference to it which appears
in a default value in an attribute-list declaration.</p><p><phrase diff="del"><loc href="E03" role="erratumref" />to </phrase><titleref href="#include-if-valid">not
obligated to</titleref><titleref href="#sec-rmd">standalone=&#x27;yes&#x27;</titleref>Note that non-validating processors are 
 
read and process entity declarations occurring in parameter entities or in
the external subset; for such documents,
the rule that an entity must be declared is a well-formedness constraint only
if 
.</p>
					

					

					

				</wfcnote><wfcnote id="textent"><head>Parsed Entity</head><p><kw>ENTITY</kw><kw>ENTITIES</kw><rfc2119>MUST
NOT</rfc2119><termref def="dt-unparsed">unparsed entity</termref><termref def="dt-attrval">attribute
values</termref>An entity reference 
 contain the name of an 
.
Unparsed entities may be referred to only in 
 declared to be of type 
 or 
.</p>
					

					

				</wfcnote><wfcnote id="norecursion"><head>No Recursion</head><p><rfc2119>MUST NOT</rfc2119>A parsed entity 
 contain a recursive reference to itself, either directly or indirectly.</p>
					

					

				</wfcnote><wfcnote id="indtd"><head>In DTD</head><p><rfc2119>MUST NOT</rfc2119><termref def="dt-doctype">DTD</termref>Parameter-entity references 
 appear outside
 the 
.</p>
					

					

				</wfcnote>
				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

				

			</div2><div2 id="sec-entity-decl"><div3 id="sec-internal-ent"><eg>&lt;!ENTITY Pub-Status &quot;This is a pre-release of the
 specification.&quot;&gt;</eg><head>Internal Entities</head><p><specref ref="intern-replacement" /><termdef id="dt-internent" term="Internal Entity Replacement Text"><nt def="NT-EntityValue">EntityValue</nt><term>internal entity</term>If the
entity definition is an 
, the defined
entity is called an 
. There is no separate physical
storage object, and the content of the entity is given in the declaration.</termdef><termref def="dt-litentval">literal entity value</termref><termref def="dt-repltext">replacement text</termref>
						

Note that some processing of entity and character references in the 
 may be required to produce
the correct 
: see 
.</p><p><termref def="dt-parsedent">parsed entity</termref>An internal entity is a 
.</p><p>Example of an internal entity declaration:</p>
					

					

					

					

					

				</div3><div3 id="sec-external-ent"><eg>&lt;!ENTITY open-hatch
         SYSTEM &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;
&lt;!ENTITY open-hatch
         PUBLIC &quot;-//Textuality//TEXT Standard open-hatch boilerplate//EN&quot;
         &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;
&lt;!ENTITY hatch-pic
         SYSTEM &quot;../grafix/OpenHatch.gif&quot;
         NDATA gif &gt;</eg><head>External Entities</head><note diff="add"><p>In a future edition of this specification, the XML Core Working Group intends to replace the preceding paragraph
							and list of steps with a normative reference to an upcoming revision of IETF RFC 3987, which will define
							&quot;Legacy Extended IRIs (LEIRIs)&quot;.  When this revision is available, it is the intent of the XML Core WG to use it to replace
							language similar to the above in any future revisions of XML-related specifications under its purview.</p>
						

					</note><olist><item><p><phrase diff="chg"><bibref ref="Unicode" /><loc href="E11" role="erratumref" /></phrase>Each character to be escaped is represented in UTF-8 

as one or more bytes.</p>
							

						</item><item><p><code>%</code><var>HH</var>The resulting bytes are escaped with
the URI escaping mechanism (that is, converted to 

								
,
where HH is the hexadecimal notation of the byte value).</p>
							

						</item><item><p>The original character is replaced by the resulting character sequence.</p>
							

						</item>
						

						

						

					</olist><p><termdef id="dt-extent" term="External Entity"><term>external entity</term>If the entity is not internal,
it is an 
, declared as follows:</termdef>
						

					</p><p><nt def="NT-NDataDecl">NDataDecl</nt><termref def="dt-unparsed">unparsed entity</termref>If the 
 is present, this is a general 
; otherwise it is a parsed entity.</p><p><code>#</code><code>Location:</code><termdef id="dt-sysid" term="System Identifier"><bibref ref="rfc3986" /><nt def="NT-SystemLiteral">SystemLiteral</nt><term>system
identifier</term>The 
 is called the entity&#x27;s 
. It is meant to be converted to a URI reference
(as defined in 
),
as part of the
process of dereferencing it to obtain input for the XML processor to construct the
entity&#x27;s replacement text.</termdef><termref def="dt-docent">document
entity</termref><termref def="dt-doctype">external
DTD subset</termref><termref def="dt-extent">external parameter
entity</termref>
						
 It is an error for a fragment identifier
(beginning with a 
 character) to be part of a system identifier.
Unless otherwise provided by information outside the scope of this specification
(e.g. a special XML element type defined by a particular DTD, or a processing
instruction defined by a particular application specification), relative URIs
are relative to the location of the resource within which the entity declaration
occurs. This is defined to
be the external entity containing the &#x27;&lt;&#x27; which starts the declaration, at the
point when it is parsed as a declaration.
A URI might thus be relative to the 
, to the entity containing the 
, or to some other 
. Attempts to
retrieve the resource identified by a URI may be redirected at the parser
level (for example, in an entity resolver) or below (at the protocol level,
for example, via an HTTP 
 header). In the absence of additional
information outside the scope of this specification within the resource,
the base URI of a resource is always the URI of the actual resource returned.
In other words, it is the URI of the resource retrieved after all redirection
has occurred.</p><p><bibref ref="rfc3986" /><emph>unwise</emph><rfc2119>MUST</rfc2119><rfc2119>SHOULD</rfc2119><rfc2119>MUST</rfc2119>System
identifiers (and other XML strings meant to be used as URI references) may contain
characters that, according to 
,
must be escaped before a URI can be used to retrieve the referenced resource. The
characters to be escaped are the control characters #x0 to #x1F and #x7F (most of
which cannot appear in XML), space #x20, the delimiters &#x27;&lt;&#x27; #x3C, &#x27;&gt;&#x27; #x3E and
&#x27;&quot;&#x27; #x22, the 
 characters &#x27;{&#x27; #x7B, &#x27;}&#x27; #x7D, &#x27;|&#x27; #x7C, &#x27;\&#x27; #x5C, &#x27;^&#x27; #x5E and
&#x27;`&#x27; #x60, as well as all characters above #x7F. Since escaping is not always a fully
reversible process, it 
 be performed only when absolutely necessary and as late
as possible in a processing chain. In particular, neither the process of converting
a relative URI to an absolute one nor the process of passing a URI reference to a
process or software component responsible for dereferencing it 
 trigger escaping.
When escaping does occur, it 
 be performed as follows:</p><p><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><termdef id="dt-pubid" term="Public identifier"><term>public identifier</term> In addition to a system
identifier, an external identifier may include a 
.</termdef>
						

An XML processor attempting to retrieve the entity&#x27;s content may use
any combination of
the public and system identifiers as well as additional information outside the
scope of this specification to try to generate an alternative URI reference.
If the processor is unable to do so, it 
 use the URI
reference specified in the system literal. Before a match is attempted,
all strings of white space in the public identifier 
 be normalized to
single space characters (#x20), and leading and trailing white space 

be removed.</p><p>Examples of external entity declarations:</p><scrap lang="ebnf"><head>External Entity Declaration</head><prod id="NT-ExternalID" num="75"><lhs>ExternalID</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-SystemLiteral">SystemLiteral</nt>&#x27;SYSTEM&#x27; 

								

							</rhs><rhs><nt def="NT-S">S</nt><nt def="NT-PubidLiteral">PubidLiteral</nt><nt def="NT-S">S</nt><nt def="NT-SystemLiteral">SystemLiteral</nt>| &#x27;PUBLIC&#x27; 

								

								

								

							</rhs>
							

							

							

						</prod><prod id="NT-NDataDecl" num="76"><lhs>NDataDecl</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-S">S</nt><nt def="NT-Name">Name</nt>
								
 &#x27;NDATA&#x27; 

								

							</rhs><vc def="not-declared" />
							

							

							

						</prod>
						

						

						

						

					</scrap><vcnote id="not-declared"><head>Notation Declared</head><p><nt def="NT-Name">Name</nt><rfc2119>MUST</rfc2119><termref def="dt-notation">notation</termref>The 

							
 match the declared name of a 
.</p>
						

						

					</vcnote>
					

					

					

					

					

					

					

					


					

					
					

					

					

				</div3><head>Entity Declarations</head><p><termdef id="dt-entdecl" term="entity declaration"> Entities are declared
thus:</termdef>
					

				</p><p><kw>ENTITY</kw><kw>ENTITIES</kw><nt def="NT-Name">Name</nt><rfc2119>MAY</rfc2119><termref def="dt-entref">entity
reference</termref>The 
 identifies the entity in an 
 or, in the case of an unparsed entity, in the value of
an 
 or 
 attribute. If the same entity is declared
more than once, the first declaration encountered is binding; at user option,
an XML processor 
 issue a warning if entities are declared multiple times.</p><scrap lang="ebnf"><head>Entity Declaration</head><prodgroup pcw2="5" pcw4="18.5"><prod id="NT-EntityDecl" num="70"><lhs>EntityDecl</lhs><rhs><nt def="NT-GEDecl">GEDecl</nt><nt def="NT-PEDecl">PEDecl</nt>
								

								
 | 

							</rhs>
							

							

							

						</prod><prod id="NT-GEDecl" num="71"><lhs>GEDecl</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt><nt def="NT-EntityDef">EntityDef</nt><nt def="NT-S">S</nt>&#x27;&lt;!ENTITY&#x27; 

								

								

								

								
?
&#x27;&gt;&#x27;</rhs>
							

							

						</prod><prod id="NT-PEDecl" num="72"><lhs>PEDecl</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-S">S</nt><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt><nt def="NT-PEDef">PEDef</nt><nt def="NT-S">S</nt>&#x27;&lt;!ENTITY&#x27; 
 &#x27;%&#x27; 

								

								

								

								
? &#x27;&gt;&#x27;</rhs>
							

							

							

						</prod><prod id="NT-EntityDef" num="73"><lhs>EntityDef</lhs><rhs><nt def="NT-EntityValue">EntityValue</nt><nt def="NT-ExternalID">ExternalID</nt><nt def="NT-NDataDecl">NDataDecl</nt>
								

								
| (

								
?)</rhs>
							

							

							

						</prod><prod id="NT-PEDef" num="74"><lhs>PEDef</lhs><rhs><nt def="NT-EntityValue">EntityValue</nt><nt def="NT-ExternalID">ExternalID</nt>
								
 | 

							</rhs>
							

							

						</prod>
						

						

						

						

						

						

					</prodgroup>
					

					

				</scrap>
				

				

				

				

				

				

			</div2><div2 id="TextEntities"><div3 id="sec-TextDecl"><head>The Text Declaration</head><p><rfc2119>SHOULD</rfc2119><term>text declaration</term>External parsed entities 
 each begin with a 
.</p><p><rfc2119>MUST</rfc2119><rfc2119>MUST NOT</rfc2119><termref def="dt-repltext">replacement text</termref>The text declaration 
 be provided literally, not by reference
					to a parsed entity. The text declaration
					
 appear at any
					position other than the beginning of an external parsed entity. The text declaration
          in an external parsed entity is not considered part of its 
.</p><scrap lang="ebnf"><head>Text Declaration</head><prodgroup pcw4="12.5" pcw5="13"><prod id="NT-TextDecl" num="77"><lhs>TextDecl</lhs><rhs><nt def="NT-VersionInfo">VersionInfo</nt><nt def="NT-EncodingDecl">EncodingDecl</nt><nt def="NT-S">S</nt>&#x27;&lt;?xml&#x27; 
? 

									
? &#x27;?&gt;&#x27;</rhs>
								

								

							</prod>
							

						</prodgroup>
						

						

					</scrap>
					

					

					

					

				</div3><div3 id="wf-entities"><head>Well-Formed Parsed Entities</head><note><p>Only parsed entities that are referenced directly or indirectly within the document are required to be well-formed.</p>
							

					</note><p><nt def="NT-document">document</nt><nt def="NT-extParsedEnt">extParsedEnt</nt>The document entity is well-formed if it matches the production labeled 
. An external general parsed entity is well-formed
if it matches the production labeled 
. All
external parameter entities are well-formed by definition.</p><p><nt def="NT-content">content</nt>An internal general parsed entity is well-formed if its replacement text
matches the production labeled 
. All internal
parameter entities are well-formed by definition.</p><p><termref def="dt-stag">start-tag</termref><termref def="dt-etag">end-tag</termref><termref def="dt-empty">empty-element tag</termref><termref def="dt-element">element</termref><termref def="dt-comment">comment</termref><termref def="dt-pi">processing instruction</termref><termref def="dt-charref">character
reference</termref><termref def="dt-entref">entity reference</termref>A consequence of well-formedness in general
entities is that the logical and physical
structures in an XML document are properly nested; no 
, 
, 
, 
, 
, 
, 
, or 

can begin in one entity and end in another.</p><scrap lang="ebnf"><head>Well-Formed External Parsed Entity</head><prod id="NT-extParsedEnt" num="78"><lhs>extParsedEnt</lhs><rhs><nt def="NT-TextDecl">TextDecl</nt><nt def="NT-content">content</nt>
								
? 

							</rhs>
							

							

						</prod>
						

						

					</scrap>
					

					

					

					

					

					

				</div3><div3 id="charencoding"><eg>&lt;?xml encoding=&#x27;UTF-8&#x27;?&gt;
&lt;?xml encoding=&#x27;EUC-JP&#x27;?&gt;</eg><head>Character Encoding in Entities</head><p><phrase diff="del"><loc href="E05" role="erratumref" />character encodings with any other labels, even if the encodings or labels are very similar to UTF-8 or UTF-16.</phrase><phrase diff="add"><loc href="E05" role="erratumref" />related character encodings, including but not limited to UTF-16BE, UTF-16LE, or CESU-8.</phrase><quote>UTF-8</quote><quote>UTF-16</quote><rfc2119>MUST</rfc2119>Each external parsed entity in an XML document may use a different encoding
for its characters. All XML processors 
 be able to read entities in both
the UTF-8 and UTF-16 encodings. The terms 

and 
 in this specification do not apply to 


</p><p><bibref ref="ISO10646-2000" /><bibref ref="Unicode" /><phrase diff="chg"><loc href="E11" role="erratumref" />16.8</phrase><phrase diff="del"><bibref ref="Unicode3" /><loc href="E11" role="erratumref" />, and section 2.7 of </phrase><rfc2119>MUST</rfc2119><rfc2119>MAY</rfc2119><rfc2119>MUST</rfc2119>Entities encoded in UTF-16 
 and entities
encoded in UTF-8 
 begin with the Byte Order Mark described by
Annex H of 
, section

 of 

(the ZERO WIDTH NO-BREAK SPACE character, #xFEFF). This is an encoding signature,
not part of either the markup or the character data of the XML document. XML
processors 
 be able to use this character to differentiate between UTF-8
and UTF-16 encoded documents.</p><p diff="add"><loc href="E06" role="erratumref" />If the replacement text of an external entity is to
						begin with the character U+FEFF, and no text declaration
						is present, then a Byte Order Mark MUST be present,
						whether the entity is encoded in UTF-8 or UTF-16.</p><p><rfc2119>MUST</rfc2119><specref ref="sec-TextDecl" />Although an XML processor is required to read only entities in the UTF-8
and UTF-16 encodings, it is recognized that other encodings are used around
the world, and it may be desired for XML processors to read entities that
use them. In
the absence of external character encoding information (such as MIME headers),
parsed entities which are stored in an encoding other than UTF-8 or UTF-16

 begin with a text declaration (see 
) containing
an encoding declaration:</p><p><nt def="NT-EncName">EncName</nt><termref def="dt-docent">document entity</termref><termref def="dt-xmldecl">XML declaration</termref>In the 
, the encoding
declaration is part of the 
.
The 
 is the name of the encoding used.</p><p><bibref ref="IANA" /><emph>charset</emph><quote><code>UTF-8</code>
							

						</quote><quote><code>UTF-16</code>
							

						</quote><quote><code>ISO-10646-UCS-2</code>
							

						</quote><quote><code>ISO-10646-UCS-4</code>
							

						</quote><quote><code>ISO-8859-1</code>
							

						</quote><quote><code>ISO-8859-2</code>
							

						</quote><quote><code>ISO-8859-</code><var>n</var>
							

							

						</quote><quote><code>ISO-2022-JP</code>
							

						</quote><quote><code>Shift_JIS</code>
							

						</quote><quote><code>EUC-JP</code>
							

						</quote><quote>x-</quote><rfc2119>SHOULD</rfc2119><rfc2119>SHOULD</rfc2119><rfc2119>SHOULD</rfc2119><rfc2119>RECOMMENDED</rfc2119><rfc2119>SHOULD</rfc2119><rfc2119>SHOULD</rfc2119><rfc2119>SHOULD</rfc2119><var>n</var>In an encoding declaration, the values 
, 
,

, and 

						
 be used
for the various encodings and transformations of Unicode / ISO/IEC 10646,
the values 
, 
,
... 
 (where 

is the part number) 
 be used for the parts of ISO 8859, and
the values 
, 
,
and 

						
 be used for the various encoded
forms of JIS X-0208-1997. It
is 
 that character encodings registered (as 
s)
with the Internet Assigned Numbers Authority 
,
other than those just listed, be referred to using their registered names;
other encodings 
 use names starting with an 
 prefix.
XML processors 
 match character encoding names in a case-insensitive
way and 
 either interpret an IANA-registered name as the encoding registered
at IANA for that name or treat it as unknown (processors are, of course, not
required to support all IANA-registered encodings).</p><p><termref def="dt-fatal">fatal error</termref>In the absence of information provided by an external transport protocol
(e.g. HTTP or MIME), it is a 
 for
an entity including an encoding declaration to be presented to the XML processor
in an encoding other than that named in the declaration, or for an entity which
begins with neither a Byte Order Mark
nor an encoding declaration to use an encoding other than UTF-8. Note that
since ASCII is a subset of UTF-8, ordinary ASCII entities do not strictly
need an encoding declaration.</p><p><nt def="NT-TextDecl">TextDecl</nt><termref def="dt-fatal">fatal error</termref>It is a 
 for a 
 to occur other
than at the beginning of an external entity.</p><p><phrase diff="del"><loc href="E11" role="erratumref" />irregular</phrase><phrase diff="add"><loc href="E11" role="erratumref" />ill-formed</phrase><phrase diff="add"><loc href="E11" role="erratumref" />section 3.9 of </phrase><phrase diff="del"><loc href="E11" role="erratumref" />3.1 </phrase><phrase diff="chg"><bibref ref="Unicode" /><loc href="E11" role="erratumref" /></phrase><termref def="dt-fatal">fatal error</termref><termref def="dt-fatal">fatal error</termref><termref def="dt-fatal">fatal error</termref>It is a 
 when an XML processor
encounters an entity with an encoding that it is unable to process. It
is a 
 if an XML entity is determined (via default, encoding declaration,
or higher-level protocol) to be in a certain encoding but contains byte
sequences that are not legal in that encoding. Specifically, it is a
fatal error if an entity encoded in UTF-8 contains any 
 code unit sequences,
as defined in 
 Unicode 
. Unless an encoding
is determined by a higher-level protocol, it is also a 
 if an XML entity
contains no encoding declaration and its content is not legal UTF-8 or UTF-16.</p><p>Examples of text declarations containing encoding declarations:</p><scrap lang="ebnf"><head>Encoding Declaration</head><prod id="NT-EncodingDecl" num="80"><lhs>EncodingDecl</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-Eq">Eq</nt><nt def="NT-EncName">EncName</nt><nt def="NT-EncName">EncName</nt>
								
 &#x27;encoding&#x27; 

(&#x27;&quot;&#x27; 
 &#x27;&quot;&#x27; | &quot;&#x27;&quot; 

&quot;&#x27;&quot; ) </rhs>
							

							

						</prod><prod id="NT-EncName" num="81"><com>Encoding
name contains only Latin characters</com><lhs>EncName</lhs><rhs>[A-Za-z] ([A-Za-z0-9._] | &#x27;-&#x27;)*</rhs>
							

							

							

						</prod>
						

						

						

					</scrap>
					

					


					

					
					


					

					

					

					

					

					

					

					

					

					

				</div3><head>Parsed Entities</head>
				

				

				

				

			</div2><div2 id="entproc"><div3 id="not-recognized"><head>Not Recognized</head><p><code>%</code><nt def="NT-content">content</nt>Outside the DTD, the 
 character has no special significance;
thus, what would be parameter entity references in the DTD are not recognized
as markup in 
. Similarly, the names of unparsed
entities are not recognized except when they appear in the value of an appropriately
declared attribute.</p>
					

					

				</div3><div3 id="included"><head>Included</head><p><quote><code>AT&amp;T;</code>
							

						</quote><quote><code>AT&amp;T;</code>
							

						</quote><rfc2119>MUST</rfc2119><term>included</term><termdef id="dt-include" term="Include"><term>included</term><termref def="dt-repltext">replacement text</termref>An entity is 

when its 
 is retrieved
and processed, in place of the reference itself, as though it were part of
the document at the location the reference was recognized.</termdef><termref def="dt-chardata">character data</termref><termref def="dt-markup">markup</termref>
						
 The replacement
text may contain both 

and (except for parameter entities) 
,
which 
 be recognized in the usual way. (The string 

expands to 
 and the remaining ampersand
is not recognized as an entity-reference delimiter.) A character reference
is 
 when the indicated character is processed in place
of the reference itself. </p>
					

					

				</div3><div3 id="include-if-valid"><head>Included If Validating</head><p><rfc2119>MUST</rfc2119><rfc2119>MAY</rfc2119><rfc2119>MUST</rfc2119><termref def="dt-valid">validate</termref><termref def="dt-include">include</termref>When an XML processor recognizes a reference to a parsed entity, in order
to 
 the document, the processor


						
 its replacement text. If
the entity is external, and the processor is not attempting to validate the
XML document, the processor 
, but need
not, include the entity&#x27;s replacement text. If a non-validating processor
does not include the replacement text, it 
 inform the application that
it recognized, but did not read, the entity.</p><p>This rule is based on the recognition that the automatic inclusion provided
by the SGML and XML entity mechanism, primarily designed to support modularity
in authoring, is not necessarily appropriate for other applications, in particular
document browsing. Browsers, for example, when encountering an external parsed
entity reference, might choose to provide a visual indication of the entity&#x27;s
presence and retrieve it for display only on demand.</p>
					

					

					

				</div3><div3 id="forbidden"><head>Forbidden</head><p><termref def="dt-fatal">fatal
errors</termref>The following are forbidden, and constitute 
:</p><ulist><item><p><nt def="NT-EntityValue">EntityValue</nt><termref def="dt-unparsed">unparsed
entity</termref>the appearance of a reference to an 
, except in the

 in an entity declaration.</p>
							

						</item><item><p><nt def="NT-EntityValue">EntityValue</nt><nt def="NT-AttValue">AttValue</nt>the appearance of any character or general-entity reference in the
DTD except within an 
 or 
.</p>
							

						</item><item><p>a reference to an external entity in an attribute value.</p>
							

						</item>
						

						

						

					</ulist>
					

					

					

				</div3><div3 id="inliteral"><eg>&lt;!ENTITY % YN &#x27;&quot;Yes&quot;&#x27; &gt;
&lt;!ENTITY WhatHeSaid &quot;He said %YN;&quot; &gt;</eg><eg>&lt;!ENTITY EndAttr &quot;27&#x27;&quot; &gt;
&lt;element attribute=&#x27;a-&amp;EndAttr;&gt;</eg><head>Included in Literal</head><p><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST NOT</rfc2119><termref def="dt-entref">entity reference</termref><termref def="dt-repltext">replacement text</termref>When an 
 appears in
an attribute value, or a parameter entity reference appears in a literal entity
value, its 

						
 be processed
in place of the reference itself as though it were part of the document at
the location the reference was recognized, except that a single or double
quote character in the replacement text 
 always be treated as a normal data
character and 
 terminate the literal. For example, this is well-formed:</p><p>while this is not:</p>
					

					

					

					

					

				</div3><div3 id="notify"><head>Notify</head><p><kw>ENTITY</kw><kw>ENTITIES</kw><rfc2119>MUST</rfc2119><termref def="dt-unparsed">unparsed entity</termref><termref def="dt-sysid">system</termref><termref def="dt-pubid">public</termref><termref def="dt-notation">notation</termref>When the name of an 

appears as a token in the value of an attribute of declared type 

or 
, a validating processor 
 inform the application of
the 
 and 

(if any) identifiers for both the entity and its associated 
.</p>
					

					

				</div3><div3 id="bypass"><head>Bypassed</head><p><nt def="NT-EntityValue">EntityValue</nt><rfc2119>MUST</rfc2119>When a general entity reference appears in the 

in an entity declaration, it 
 be bypassed and left as is.</p>
					

					

				</div3><div3 id="as-PE"><head>Included as PE</head><p><rfc2119>MUST</rfc2119><rfc2119>MUST NOT</rfc2119><specref ref="inliteral" /><termref def="dt-repltext">replacement
text</termref><titleref href="#include-if-valid">included if validating</titleref>Just as with external parsed entities, parameter entities need only be 
. When a parameter-entity
reference is recognized in the DTD and included, its 

						
 be enlarged by the attachment of one leading and one following
space (#x20) character; the intent is to constrain the replacement text of
parameter entities to contain an integral number of grammatical tokens in
the DTD. This
behavior 
 apply to parameter entity references within entity values;
these are described in 
.</p>
					

					

				</div3><div3 id="error"><head>Error</head><p><nt def="NT-EntityValue">EntityValue</nt><termref def="dt-error">error</termref>It is an 
 for a reference to
		an unparsed entity to appear in the 
 in an
		entity declaration.</p>
					

					

				</div3><head>XML Processor Treatment of Entities and References</head><p><glist><gitem><def><p><nt def="NT-content">content</nt><termref def="dt-stag">start-tag</termref><termref def="dt-etag">end-tag</termref>as a reference anywhere after the 

and before the 
 of an element; corresponds
to the nonterminal 
.</p>
								

							</def><label>Reference in Content</label>
							

							

						</gitem><gitem><def><p><nt def="NT-AttValue">AttValue</nt><termref def="dt-stag">start-tag</termref><termref def="dt-attdecl">attribute declaration</termref>as a reference within either the value of an attribute in a 
,
or a default value in an 
;
corresponds to the nonterminal 
.</p>
								

							</def><label>Reference in Attribute Value</label>
							

							

						</gitem><gitem><def><p><kw>ENTITY</kw><kw>ENTITIES</kw><nt def="NT-Name">Name</nt>as a 
, not a reference, appearing either as
the value of an attribute which has been declared as type 
,
or as one of the space-separated tokens in the value of an attribute which
has been declared as type 
.</p>
								

							</def><label>Occurs as Attribute Value</label>
							

							

						</gitem><gitem><def><p><nt def="NT-EntityValue">EntityValue</nt><termref def="dt-litentval">literal
entity value</termref>as a reference within a parameter or internal entity&#x27;s 
 in the entity&#x27;s declaration; corresponds to the nonterminal 
.</p>
								

							</def><label>Reference in Entity Value</label>
							

							

						</gitem><gitem><def><p><nt def="NT-EntityValue">EntityValue</nt><nt def="NT-AttValue">AttValue</nt><nt def="NT-PI">PI</nt><nt def="NT-Comment">Comment</nt><nt def="NT-SystemLiteral">SystemLiteral</nt><nt def="NT-PubidLiteral">PubidLiteral</nt><specref ref="sec-condition-sect" /><termref def="dt-doctype">DTD</termref>as a reference within either the internal or external subsets of the 
, but outside of an 
, 
, 
, 
, 
, 
,
or the contents of an ignored conditional section (see 
).</p><p>.</p>
								

								

							</def><label>Reference in DTD</label>
							

							

						</gitem>
						

						

						

						

						

					</glist><rfc2119>REQUIRED</rfc2119><termref def="dt-xml-proc">XML processor</termref>The table below summarizes the contexts in which character references,
entity references, and invocations of unparsed entities might appear and the

 behavior of an 

in each case. The labels in the leftmost column describe the recognition context: 

				</p><table border="1" cellpadding="7" frame="border"><tbody align="center"><tr><td colspan="1" rowspan="2" /><td align="center" colspan="4" valign="bottom">Entity
Type</td><td align="center" rowspan="2">Character</td>
							

							

							

						</tr><tr align="center" valign="bottom"><td>Parameter</td><td>Internal General</td><td>External Parsed
General</td><td>Unparsed</td>
							

							

							

							

						</tr><tr align="center" valign="middle"><td align="right">Reference
in Content</td><td><titleref href="#not-recognized">Not recognized</titleref>
								

							</td><td><titleref href="#included">Included</titleref>
								

							</td><td><titleref href="#include-if-valid">Included
if validating</titleref>
								

							</td><td><titleref href="#forbidden">Forbidden</titleref>
								

							</td><td><titleref href="#included">Included</titleref>
								

							</td>
							

							

							

							

							

							

						</tr><tr align="center" valign="middle"><td align="right">Reference in Attribute Value</td><td><titleref href="#not-recognized">Not recognized</titleref>
								

							</td><td><titleref href="#inliteral">Included
in literal</titleref>
								

							</td><td><titleref href="#forbidden">Forbidden</titleref>
								

							</td><td><titleref href="#forbidden">Forbidden</titleref>
								

							</td><td><titleref href="#included">Included</titleref>
								

							</td>
							

							

							

							

							

							

						</tr><tr align="center" valign="middle"><td align="right">Occurs as Attribute
Value</td><td><titleref href="#not-recognized">Not recognized</titleref>
								

							</td><td><titleref href="#forbidden">Forbidden</titleref>
								

							</td><td><titleref href="#forbidden">Forbidden</titleref>
								

							</td><td><titleref href="#notify">Notify</titleref>
								

							</td><td><titleref href="#not-recognized">Not recognized</titleref>
								

							</td>
							

							

							

							

							

							

						</tr><tr align="center" valign="middle"><td align="right">Reference in EntityValue</td><td><titleref href="#inliteral">Included in literal</titleref>
								

							</td><td><titleref href="#bypass">Bypassed</titleref>
								

							</td><td><titleref href="#bypass">Bypassed</titleref>
								

							</td><td><titleref href="#error">Error</titleref>
								

							</td><td><titleref href="#included">Included</titleref>
								

							</td>
							

							

							

							

							

							

						</tr><tr align="center" valign="middle"><td align="right">Reference in DTD</td><td><titleref href="#as-PE">Included as PE</titleref>
								

							</td><td><titleref href="#forbidden">Forbidden</titleref>
								

							</td><td><titleref href="#forbidden">Forbidden</titleref>
								

							</td><td><titleref href="#forbidden">Forbidden</titleref>
								

							</td><td><titleref href="#forbidden">Forbidden</titleref>
								

							</td>
							

							

							

							

							

							

						</tr>
						

						

						

						

						

						

						

					</tbody>
					

				</table>
				

				

				

				

				

				

				

				

				

				

				

				

			</div2><div2 id="intern-replacement"><eg>&lt;!ENTITY % pub    &quot;&amp;#xc9;ditions Gallimard&quot; &gt;
&lt;!ENTITY   rights &quot;All rights reserved&quot; &gt;
&lt;!ENTITY   book   &quot;La Peste: Albert Camus,
&amp;#xA9; 1947 %pub;. &amp;rights;&quot; &gt;</eg><eg xml:lang="fr">La Peste: Albert Camus,
© 1947 Éditions Gallimard. &amp;rights;</eg><head>Construction of Entity Replacement Text</head><p><termdef id="dt-litentval" term="Literal Entity Value"><nt def="NT-EntityValue">EntityValue</nt><term>literal
entity value</term>For an
internal entity, the 
 is the quoted string actually present in the entity declaration,
corresponding to the non-terminal 
.</termdef><termdef id="dt-extlitentval" term="Literal Entity Value"><term>literal
entity value</term>For an external entity, the 
 is the exact text contained in the entity.</termdef><termdef id="dt-repltext" term="Replacement Text"><term>replacement text</term>For an
internal entity, the 

is the content of the entity, after replacement of character references and
parameter-entity references.</termdef><termdef id="dt-extrepltext" term="Replacement Text"><term>replacement text</term>For
an external entity, the 
 is the content of the entity,
after stripping the text declaration (leaving any surrounding whitespace) if there
is one but without any replacement of character references or parameter-entity
references.</termdef>In discussing the treatment of entities, it is useful to distinguish
two forms of the entity&#x27;s value.


					

					

					

				</p><p><emph>replacement
text</emph><nt def="NT-EntityValue">EntityValue</nt><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><rfc2119>MUST</rfc2119><termref def="dt-include">included</termref><termref def="inliteral">included in literal</termref>The literal entity value as given in an internal entity declaration (
) may contain character, parameter-entity,
and general-entity references. Such references 
 be contained entirely
within the literal entity value. The actual replacement text that is 
 (or 
) as described above

 contain the 
 of any parameter entities referred to, and 
 contain the character
referred to, in place of any character references in the literal entity value;
however, general-entity references 
 be left as-is, unexpanded. For example,
given the following declarations:</p><p><quote><code>book</code>
						

					</quote>then the replacement text for the entity 

is:</p><p><quote><code>&amp;rights;</code>
						

					</quote><quote><code>&amp;book;</code>
						

					</quote>The general-entity reference 
 would
be expanded should the reference 
 appear
in the document&#x27;s content or an attribute value.</p><p><specref ref="sec-entexpand" />These simple rules may have complex interactions; for a detailed discussion
of a difficult example, see 
.</p>
				

				

				

				

				

				

				

				

			</div2><div2 id="sec-predefined-ent"><eg>&lt;!ENTITY lt     &quot;&amp;#38;#60;&quot;&gt;
&lt;!ENTITY gt     &quot;&amp;#62;&quot;&gt;
&lt;!ENTITY amp    &quot;&amp;#38;#38;&quot;&gt;
&lt;!ENTITY apos   &quot;&amp;#39;&quot;&gt;
&lt;!ENTITY quot   &quot;&amp;#34;&quot;&gt;</eg><head>Predefined Entities</head><p><termdef id="dt-escape" term="escape"><code>amp</code><code>lt</code><code>gt</code><code>apos</code><code>quot</code><code>&lt;</code><code>&amp;</code><quote><code>&amp;#60;</code>
							

						</quote><quote><code>&amp;#38;</code>
							

						</quote><rfc2119>MUST</rfc2119><term>escape</term>Entity and character references may
both be used to 
 the left angle bracket, ampersand, and
other delimiters. A set of general entities (
, 
, 
, 
, 
) is specified for
this purpose. Numeric character references may also be used; they are expanded
immediately when recognized and 
 be treated as character data, so the
numeric character references 
 and 
 may be used to escape 
 and 
 when they occur
in character data.</termdef>
					

				</p><p><code>lt</code><code>amp</code><code>gt</code><code>apos</code><code>quot</code><rfc2119>MUST</rfc2119><rfc2119>SHOULD</rfc2119><rfc2119>MUST</rfc2119><rfc2119>REQUIRED</rfc2119><rfc2119>MUST</rfc2119><rfc2119>OPTIONAL</rfc2119><termref def="dt-interop">For interoperability</termref>All XML processors 
 recognize these entities whether they are declared
or not. 
, valid XML
documents 
 declare these entities, like any others, before using them. If
the entities 
 or 
 are declared, they 
 be
declared as internal entities whose replacement text is a character reference
to the respective
character (less-than sign or ampersand) being escaped; the double
escaping is 
 for these entities so that references to them produce
a well-formed result. If the entities 
, 
,
or 
 are declared, they 
 be declared as internal entities
whose replacement text is the single character being escaped (or a character
reference to that character; the double escaping here is 
 but harmless).
For example:</p>
				

				

				

				

			</div2><div2 id="Notations"><head>Notation Declarations</head><p><termdef id="dt-notation" term="Notation"><term>Notations</term><termref def="dt-unparsed">unparsed entities</termref><termref def="dt-pi">processing instruction</termref>
						
 identify
by name the format of 
,
the format of elements which bear a notation attribute, or the application
to which a 
 is addressed.</termdef>
					

				</p><p><termdef id="dt-notdecl" term="Notation Declaration"><term>Notation declarations</term>
						

provide a name for the notation, for use in entity and attribute-list declarations
and in attribute specifications, and an external identifier for the notation
which may allow an XML processor or its client application to locate a helper
application capable of processing data in the given notation.</termdef>
					

				</p><p><rfc2119>MUST</rfc2119><rfc2119>MAY</rfc2119><termref def="dt-sysid">system identifier</termref>XML processors 
 provide applications with the name and external identifier(s)
of any notation declared and referred to in an attribute value, attribute
definition, or entity declaration. They 
 additionally resolve the external
identifier into the 
, file
name, or other information needed to allow the application to call a processor
for data in the notation described. (It is not an error, however, for XML
documents to declare and refer to notations for which notation-specific applications
are not available on the system where the XML processor or application is
running.)</p><scrap lang="ebnf"><head>Notation Declarations</head><prod id="NT-NotationDecl" num="82"><lhs>NotationDecl</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-Name">Name</nt><nt def="NT-S">S</nt><nt def="NT-ExternalID">ExternalID</nt><nt def="NT-PublicID">PublicID</nt><nt def="NT-S">S</nt>&#x27;&lt;!NOTATION&#x27; 

							

							
 (
 | 
) 
? &#x27;&gt;&#x27;</rhs><vc def="UniqueNotationName" />
						

						

						

					</prod><prod id="NT-PublicID" num="83"><lhs>PublicID</lhs><rhs><nt def="NT-S">S</nt><nt def="NT-PubidLiteral">PubidLiteral</nt>&#x27;PUBLIC&#x27; 

							

						</rhs>
						

						

					</prod>
					

					

					

				</scrap><vcnote id="UniqueNotationName"><head>Unique Notation Name</head><p><nt def="NT-Name">Name</nt><rfc2119>MUST NOT</rfc2119>A given 

						
 be declared in more than one notation declaration.</p>
					

					

				</vcnote>
				

				

				

				

				

				

			</div2><div2 id="sec-doc-entity"><head>Document Entity</head><p><termdef id="dt-docent" term="Document Entity"><term>document entity</term><termref def="dt-xml-proc">XML processor</termref>The 

serves as the root of the entity tree and a starting-point for an 
.</termdef>
					
 This specification does
not specify how the document entity is to be located by an XML processor;
unlike other entities, the document entity has no name and might well appear
on a processor input stream without any identification at all.</p>
				

				

			</div2><head>Physical Structures</head><p><termdef id="dt-entity" term="Entity"><term>entities</term><term>content</term><term>name</term><termref def="dt-docent">document entity</termref><termref def="dt-doctype">external DTD subset</termref>An XML document may consist of one
or many storage units. These
are called 
; they all have 
 and are
all (except for the 
 and
the 
) identified by
entity 
.</termdef><termref def="dt-docent">document entity</termref><termref def="dt-xml-proc">XML processor</termref>
				
 Each XML document has one entity
called the 
, which serves
as the starting point for the 

and may contain the whole document.</p><p><termdef id="dt-parsedent" term="Text Entity"><term>parsed
entity</term><termref def="dt-repltext">replacement
text</termref><termref def="dt-text">text</termref>The contents of a 
 are referred to as its 
; this 
 is considered an
integral part of the document.</termdef>Entities may be either parsed or unparsed. 

			</p><p><termdef id="dt-unparsed" term="Unparsed Entity"><term>unparsed entity</term><termref def="dt-text">text</termref><termref def="dt-notation">notation</termref>An 

is a resource whose contents may or may not be 
,
and if text, may
be other than XML. Each unparsed entity has an associated 
, identified by name. Beyond a requirement
that an XML processor make the identifiers for the entity and notation available
to the application, XML places no constraints on the contents of unparsed
entities.</termdef>
				

			</p><p><kw>ENTITY</kw><kw>ENTITIES</kw>Parsed entities are invoked by name using entity references; unparsed entities
by name, given in the value of 
 or 
 attributes.</p><p><termdef id="gen-entity" term="general entity"><emph>entity</emph><term>General entities</term>
					

are entities for use within the document content. In this specification, general
entities are sometimes referred to with the unqualified term 

when this leads to no ambiguity.</termdef><termdef id="dt-PE" term="Parameter entity"><term>Parameter
entities</term>
					
 are parsed entities for use within the DTD.</termdef>
				

				

These two types of entities use different forms of reference and are recognized
in different contexts. Furthermore, they occupy different namespaces; a parameter
entity and a general entity with the same name are two distinct entities.</p>
			

			

			

			

			

			

			

			

			

			

			

			

			

			

		</div1><div1 id="sec-conformance"><div2 id="proc-types"><head>Validating and Non-Validating Processors</head><p><termref def="dt-xml-proc">XML processors</termref>Conforming 
 fall into
two classes: validating and non-validating.</p><p><rfc2119>MUST</rfc2119><termref def="dt-docent">document entity</termref><termref def="dt-parsedent">parsed
entities</termref>Validating and non-validating processors alike 
 report violations of
this specification&#x27;s well-formedness constraints in the content of the 
 and any other 
 that they read.</p><p><rfc2119>MUST</rfc2119><termdef id="dt-validating" term="Validating Processor"><rfc2119>MUST</rfc2119><term>Validating
processors</term><termref def="dt-doctype">DTD</termref>
						

						
,
at user option, report violations of the constraints expressed by
the declarations in the 
, and failures
to fulfill the validity constraints given in this specification.</termdef>
					

To accomplish this, validating XML processors 
 read and process the entire
DTD and all external parsed entities referenced in the document.</p><p><code>standalone=&quot;yes&quot;</code><code>standalone=&quot;yes&quot;</code><rfc2119>REQUIRED</rfc2119><rfc2119>MUST NOT</rfc2119><rfc2119>MUST</rfc2119><termdef id="dt-use-mdecl" term="Process Declarations"><emph>not</emph><rfc2119>REQUIRED</rfc2119><rfc2119>MUST</rfc2119><term>process</term><titleref href="#AVNormalize">normalize</titleref><titleref href="#included">include</titleref><titleref href="#sec-attr-defaults">default
attribute values</titleref> While they are not required
to check the document for validity, they are 
 to 

all the declarations they read in the internal DTD subset and in any parameter
entity that they read, up to the first reference to a parameter entity that
they do 
 read; that is to say, they 
 use the information
in those declarations to 

attribute values, 
 the replacement
text of internal entities, and supply 
.</termdef><termref def="dt-docent">document
entity</termref><termref def="dt-use-mdecl">process</termref><termref def="dt-entdecl">entity
declarations</termref><termref def="dt-attdecl">attribute-list declarations</termref>Non-validating processors are 
 to check only the 
, including the entire internal DTD subset, for well-formedness. 
 Except when 
, they


					

					
 or 

encountered after a reference to a parameter entity that is not read, since
the entity may have contained overriding declarations; when 
, processors 

process these declarations.</p><p>Note that when processing invalid documents with a non-validating
processor the application may not be presented with consistent
information.  For example, several requirements for uniqueness
within the document may not be met, including more than one element
with the same id, duplicate declarations of elements or notations
with the same name, etc.  In these cases the behavior of the parser
with respect to reporting such information to the application is
undefined.</p>
				

				

				

				

				

				

			</div2><div2 id="safe-behavior"><head>Using XML Processors</head><p>The behavior of a validating XML processor is highly predictable; it must
read every piece of a document and report all well-formedness and validity
violations. Less is required of a non-validating processor; it need not read
any part of the document other than the document entity. This has two effects
that may be important to users of XML processors:</p><p><rfc2119>SHOULD NOT</rfc2119><rfc2119>SHOULD</rfc2119>For maximum reliability in interoperating between different XML processors,
applications which use non-validating processors 
 rely on any behaviors
not required of such processors. Applications which require DTD facilities not related to validation (such
as the declaration of default attributes and internal entities that are or may be specified in
external entities) 
 use validating XML processors.</p><ulist><item><p><specref ref="entproc" /><titleref href="#wf-entdeclared">Entity Declared</titleref><titleref href="#textent">Parsed Entity</titleref><titleref href="#norecursion">No
Recursion</titleref><titleref href="#forbidden">forbidden</titleref>Certain well-formedness errors, specifically those that require reading
external entities, may fail to be detected by a non-validating processor. Examples
include the constraints entitled 
, 
, and 
, as well as some of the cases described as 
 in 
.</p>
						

					</item><item><p><phrase diff="add"><loc href="E04" role="erratumref" />, or in the internal subset after an unread 
parameter entity reference</phrase><titleref href="#AVNormalize">normalize</titleref><titleref href="#included">include</titleref><titleref href="#sec-attr-defaults">default
attribute values</titleref>The information passed from the processor to the application may
vary, depending on whether the processor reads parameter and external entities.
For example, a non-validating processor may fail to 

attribute values, 
 the replacement
text of internal entities, or supply 
, where doing so depends on having read declarations
in external or parameter entities
.</p>
						

					</item>
					

					

				</ulist>
				

				

				

				

			</div2><head>Conformance</head>
			

			

			

		</div1><div1 id="sec-notation"><eg>symbol ::= expression</eg><head>Notation</head><p>The formal grammar of XML is given in this specification using a simple
Extended Backus-Naur Form (EBNF) notation. Each rule in the grammar defines
one symbol, in the form</p><p>Symbols are written with an initial capital letter if they are the
start symbol of a regular language, otherwise with an initial lowercase letter.
Literal strings are quoted.</p><p><code>A</code><code>B</code><glist><gitem><def><p><code>N</code><code>N</code><code>#xN</code>where 
 is a hexadecimal integer, the expression matches the character
whose number
(code point) in ISO/IEC 10646 is 
. The number of leading zeros in the 

form is insignificant.</p>
							

						</def><label><code>#xN</code>
							

						</label>
						

						

					</gitem><gitem><def><p><nt def="NT-Char">Char</nt>matches any 
 with a value in the range(s) indicated (inclusive).</p>
							

						</def><label><code>[a-zA-Z]</code><code>[#xN-#xN]</code>
							
, 

						</label>
						

						

					</gitem><gitem><def><p><nt def="NT-Char">Char</nt>matches any 
 with a value among the characters
enumerated. Enumerations and ranges can be mixed in one set of brackets.</p>
							

						</def><label><code>[abc]</code><code>[#xN#xN#xN]</code>
							
, 

						</label>
						

						

					</gitem><gitem><def><p><emph>outside</emph><nt def="NT-Char">Char</nt>matches any 
 with a value 
 the range
indicated.</p>
							

						</def><label><code>[^a-z]</code><code>[^#xN-#xN]</code>
							
, 

						</label>
						

						

					</gitem><gitem><def><p><nt def="NT-Char">Char</nt>matches any 
 with a value not among the characters given. Enumerations
and ranges of forbidden values can be mixed in one set of brackets.</p>
							

						</def><label><code>[^abc]</code><code>[^#xN#xN#xN]</code>
							
, 

						</label>
						

						

					</gitem><gitem><def><p><termref def="dt-match">matching</termref>matches a literal string 
 that
given inside the double quotes.</p>
							

						</def><label><code>&quot;string&quot;</code>
							

						</label>
						

						

					</gitem><gitem><def><p><termref def="dt-match">matching</termref>matches a literal string 
 that
given inside the single quotes.</p>
							

						</def><label><code>&#x27;string&#x27;</code>
							

						</label>
						

						

					</gitem>
					

					

					

					

					

					

					

				</glist><glist><gitem><def><p><code>expression</code>
								
 is treated as a unit and may be combined as described
in this list.</p>
							

						</def><label><code>expression</code>(
)</label>
						

						

					</gitem><gitem><def><p><code>A</code><code>A</code>matches 
 or nothing; optional 
.</p>
							

						</def><label><code>A?</code>
							

						</label>
						

						

					</gitem><gitem><def><p><code>A</code><code>B</code><code>A B | C D</code><code>(A B) | (C D)</code>matches 
 followed by 
. This
operator has higher precedence than alternation; thus 

is identical to 
.</p>
							

						</def><label><code>A B</code>
							

						</label>
						

						

					</gitem><gitem><def><p><code>A</code><code>B</code>matches 
 or 
.</p>
							

						</def><label><code>A | B</code>
							

						</label>
						

						

					</gitem><gitem><def><p><code>A</code><code>B</code>matches any string that matches 
 but does not match 
.</p>
							

						</def><label><code>A - B</code>
							

						</label>
						

						

					</gitem><gitem><def><p><code>A</code><code>A+ | B+</code><code>(A+) | (B+)</code>matches one or more occurrences of 
. Concatenation
has higher precedence than alternation; thus 
 is identical
to 
.</p>
							

						</def><label><code>A+</code>
							

						</label>
						

						

					</gitem><gitem><def><p><code>A</code><code>A* | B*</code><code>(A*) | (B*)</code>matches zero or more occurrences of 
. Concatenation
has higher precedence than alternation; thus 
 is identical
to 
.</p>
							

						</def><label><code>A*</code>
							

						</label>
						

						

					</gitem>
					

					

					

					

					

					

					

				</glist><glist><gitem><def><p>comment.</p>
							

						</def><label><code>/* ... */</code>
							

						</label>
						

						

					</gitem><gitem><def><p><termref def="dt-wellformed">well-formed</termref>well-formedness constraint; this identifies by name a constraint on 
 documents associated with a production.</p>
							

						</def><label><code>[ wfc: ... ]</code>
							

						</label>
						

						

					</gitem><gitem><def><p><termref def="dt-valid">valid</termref>validity constraint; this identifies by name a constraint on 

documents associated with a production.</p>
							

						</def><label><code>[ vc: ... ]</code>
							

						</label>
						

						

					</gitem>
					

					

					

				</glist>Within the expression on the right-hand side of a rule, the following expressions
are used to match strings of one or more characters: 
 These symbols may be combined to match more complex patterns as follows,
where 
 and 
 represent simple expressions: 
 Other notations used in the productions are: 

			</p>
			

			

			

			

			

		</div1>
		

		

		

		

		

		

		

		

		

		

	</body><header><abstract><p>The Extensible Markup Language (XML) is a subset of SGML that is completely
described in this document. Its goal is to enable generic SGML to be served,
received, and processed on the Web in the way that is now possible with HTML.
XML has been designed for ease of implementation and for interoperability
with both SGML and HTML.</p>
			

		</abstract><altlocs><loc href="REC-xml-20081126.xml">XML</loc><loc href="REC-xml-20081126-review.html">XHTML with color-coded revision indicators</loc>
			

			

			

		</altlocs><authlist><author role="1e"><affiliation>Textuality and Netscape</affiliation><email href="mailto:tbray@textuality.com">tbray@textuality.com</email><name>Tim Bray</name>
				

				

				

			</author><author role="1e"><affiliation>Microsoft</affiliation><email href="mailto:jeanpa@microsoft.com">jeanpa@microsoft.com</email><name>Jean Paoli</name>
				

				

				

			</author><author role="1e"><affiliation>W3C</affiliation><email href="mailto:cmsmcq@w3.org">cmsmcq@w3.org</email><name>C. M. Sperberg-McQueen</name>
				

				

				

			</author><author><affiliation>Sun Microsystems, Inc.</affiliation><email href="mailto:elm@east.sun.com">eve.maler@east.sun.com</email><name>Eve Maler</name>
				

				

				

			</author><author><name>François Yergeau</name>
				

			</author>
			

			

			

			

			

		</authlist><errataloc href="http://www.w3.org/XML/xml-V10-5e-errata" /><langusage><language id="EN">English</language><language id="ebnf">Extended Backus-Naur Form (formal grammar)</language>
			

			

		</langusage><latestloc><loc href="http://www.w3.org/TR/xml/">http://www.w3.org/TR/xml/</loc>
			

		</latestloc><preverrataloc href="http://www.w3.org/XML/xml-V10-4e-errata" /><prevlocs><loc href="http://www.w3.org/TR/2008/PER-xml-20080205/">http://www.w3.org/TR/2008/PER-xml-20080205/</loc><loc href="http://www.w3.org/TR/2006/REC-xml-20060816/">http://www.w3.org/TR/2006/REC-xml-20060816/</loc>
   

			

		</prevlocs><pubdate><day>26</day><month>November</month><year>2008</year>
			

			

			

		</pubdate><publoc><loc href="http://www.w3.org/TR/2008/REC-xml-20081126/">http://www.w3.org/TR/2008/REC-xml-20081126/</loc>
			

		</publoc><pubstmt><p>Chicago, Vancouver, Mountain View, Edinburgh, et al.: World-Wide Web Consortium, XML
Working Group, 1996, 1997, 2000, 2006, 2008.</p>
			

		</pubstmt><revisiondesc><p role="cvsid">$Id: REC-xml-20081126.xml,v 1.3 2013-02-07 15:01:59 denis Exp $</p>
			

		</revisiondesc><sourcedesc><p>Created in electronic form.</p>
			

		</sourcedesc><status><p><emph><loc href="http://www.w3.org/TR/">W3C technical reports index</loc>This section describes the status of this document at the time of its publication.
				Other documents may supersede this document. A list of current W3C publications and the
				latest revision of this technical report can be found in the 
 at
				http://www.w3.org/TR/.</emph></p><p><loc href="http://www.w3.org/XML/Core/">XML Core Working Group</loc><loc href="http://www.w3.org/XML/Activity">XML Activity</loc><loc href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xml">http://www.w3.org/2003/03/Translations/byTechnology?technology=xml</loc>This document specifies a syntax created by subsetting an existing, widely
				used international text processing standard (Standard Generalized Markup Language,
				ISO 8879:1986(E) as amended and corrected) for use on the World Wide Web.
				It is a product of the 

				as part of the 
.
				The English version of this specification is the only normative version. However,
				for translations of this document, see 
.</p><p><emph>not</emph><loc href="http://www.w3.org/2005/10/Process-20051014/tr.html#q74">W3C Recommendation</loc><loc href="http://www.w3.org/XML/xml-V10-4e-errata">http://www.w3.org/XML/xml-V10-4e-errata</loc><loc href="http://www.w3.org/TR/2006/REC-xml-20060816/">Fourth
				Edition of XML 1.0, dated 16 August 2006</loc><loc href="http://www.w3.org/XML/xml-V10-4e-errata#E09">[E09]</loc>This document is a 
. This fifth edition is 
 a new version of XML. As a convenience to readers,
				it incorporates the changes dictated by the accumulated errata (available at
				
) to the 
.  In particular, erratum 

				relaxes the restrictions on element and attribute names, thereby providing in XML 1.0 the major end user benefit
				currently achievable only by using XML
1.1.  As a consequence, many possible
 documents which were not well-formed according to previous editions of this
 specification are now well-formed, and previously invalid documents
using the newly-allowed name characters in, for example, ID
attributes, are now valid.</p><p><loc href="http://www.w3.org/TR/2006/REC-xml-20060816/">W3C Recommendation
				of 16 August 2006</loc>This edition supersedes the previous 
.</p><p><loc href="mailto:xml-editor@w3.org">xml-editor@w3.org</loc><loc href="http://lists.w3.org/Archives/Public/xml-editor/">archives</loc><loc href="REC-xml-20081126-review.html">XHTML version with color-coded revision indicators</loc><loc href="http://www.w3.org/XML/xml-V10-4e-errata">errata
list</loc><loc href="http://www.w3.org/XML/xml-V10-5e-errata">http://www.w3.org/XML/xml-V10-5e-errata</loc>Please report errors in this document to
the public 
 mail list; public
				
 are available. For the convenience of readers,
				an 
 is
				also provided; this version highlights each change due to an erratum published in the
				
 for the previous edition, together with a link to the particular
				erratum in that list. Most of the
errata in the list provide a rationale for the change.  The errata
list for this fifth edition is available at 
.</p><p><loc href="http://www.w3.org/XML/2008/01/xml10-5e-implementation.html">http://www.w3.org/XML/2008/01/xml10-5e-implementation.html</loc><loc href="http://www.w3.org/XML/Test/">Test Suite</loc>An implementation report is available at 
.
				A 
 is maintained to help assessing conformance to this specification.</p><p>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C&#x27;s role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</p><p><loc href="http://www.w3.org/2002/08/xmlcore-IPR-statements" role="disclosure">public list of
				any patent disclosures</loc><loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
				Claim(s)</loc><loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</loc>W3C maintains a 
 made in connection with the deliverables of
				the group; that page also includes instructions for disclosing a patent.
				An individual who has actual knowledge of a patent which the individual
				believes contains 
 must disclose the information in accordance with 
				
.</p>
			


			


			



			
			

			
			





			

		</status><title>Extensible Markup Language (XML)</title><translationloc href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xml" /><version>1.0 (Fifth Edition)</version><w3c-designation>REC-xml-20081126</w3c-designation><w3c-doctype>W3C Recommendation</w3c-doctype>
		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

		

	</header>








	

	

	

</spec>