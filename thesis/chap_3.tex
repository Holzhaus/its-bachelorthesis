\chapter{Umsetzung}
\label{chap:impl}
\section{Versuchsaufbau}

\begin{figure}
    \includestandalone{flowchart_conversiontest}
    \caption{Ablauf der Konversionstests}
\end{figure}

\begin{figure}
    \includestandalone{flowchart_securitytest}
    \caption{Ablauf der Sicherheitstests}
\end{figure}

\section{Bewertungskriterien}

\subsection{Kriterien für verlustlose Konversion}

\subsubsection{CDATA-Abschnitt}

Mithilfe von CDATA-Abschnitten lässt sich Text, der Markup-Zeichen wie beispielsweise das Kleiner-als-Zeichen\footnote{Unicode-Codepoint \texttt{U+003C}: \texttt{LESS-THAN SIGN}} enthält, direkt in ein XML-Dokument einbetten, ohne dass diese Zeichen als Markup interpretiert werden.

Dies ist vor allem dann sinnvoll, wenn es unpraktikabel ist, alle Markup-Zeichen im Text einzeln durch die jeweilige Zeichen- oder Entity-Referenz zu ersetzen. CDATA stellt somit eine weitere Weg dar, Zeichendaten in einem XML-Dokument anzugeben.\cite[Abschnitt~2.4]{maler2008xml}

Der Unterschied zwischen Zeichendaten aus CDATA-Abschnitten und solchen, bei denen dies nicht der Fall ist, ist jedoch lediglich ein syntaktischer. Daher werden bei der \acrlong{c14n} alle CDATA-Abschnitte im Eingabedokument durch den entsprechenden \emph{Character Content} ersetzt\cite[Abschnitt~2.1]{boyer2001c14n}.

Für die Verlustlosigkeit der Konversion ist es daher unerheblich, ob die CDATA-Abschnitte im Ursprungsdokument als solche erhalten bleiben, oder lediglich die Zeichendaten beibehalten werden.

\subsubsection{Kommentare}

\acrshort{xml} verfügt über die Möglichkeit, Dokumente mit Kommentaren zu versehen. Allerdings müssen diese nicht durch den XML-Prozessor zugänglich gemacht werden. In der Empfehlung des \gls{w3c} heißt es dazu:

\begin{foreigndisplayquote}{english}[{\cite[Abschnitt~2.5]{maler2008xml}}]
They are not part of the document's character data; an XML processor may, but need not, make it possible for an application to retrieve the text of comments.
\end{foreigndisplayquote}

Zudem ist auch bei der Implementierung von \acrlong{c14n} die Unterstützung von \emph{Kanonischem XML mit Kommentaren} lediglich empfohlen, während die Möglichkeit der Umwandlung in \emph{Kanonisches XML} ausschließlich aller Kommentare zwingend erforderlich ist.\cite[Abschnitt~2.1]{boyer2001c14n}

Folglich ist es nicht nötig, dass sich die Kommentare im XML-Eingabedokument nach dem $XML\rightarrow{}JSON\rightarrow{}XML$ Roundtrip auch in der Ausgabe wiederfinden.

\subsubsection{Dokumentordnung}

\paragraph{Elementordnung}

Die Spezifikation der \acrshort{c14n} bezieht sich bezüglich der Ordnung auf die \acrshort{w3c}-Empfehlung zur \acrfull{xpath}\cite[Abschnitt~2.2]{boyer2001c14n}.

\begin{foreigndisplayquote}{english}[{\cite[Abschnitt~5]{clark1999xpath1}}]
There is an ordering, document order, defined on all the nodes in the document corresponding to the order in which the first character of the XML representation of each node occurs in the XML representation of the document after expansion of general entities. Thus, the root node will be the first node. Element nodes occur before their children. Thus, document order orders element nodes in order of the occurrence of their start-tag in the XML (after expansion of entities).
\end{foreigndisplayquote}

Folglich muss die Reihenfolge der Element-Nodes bei der Konversion beibehalten werden.

\paragraph{Ordnung von Attributen und Namespaces}

Laut dem \acrshort{xml}-Standard unwichtig kommen der Reihenfolge, in die Attribute eines Elements angegeben wurden, keine Bedeutung zu.

\begin{foreigndisplayquote}{english}[{\cite[Abschnitt~3.1]{maler2008xml}}]
Note that the order of attribute specifications in a start-tag or empty-element tag is not significant.
\end{foreigndisplayquote}

Dies wird auch von der \acrshort{xpath}-Spezifikation untermauert:

\begin{foreigndisplayquote}{english}[{\cite[Abschnitt~5]{clark1999xpath1}}]
The relative order of namespace nodes is implementation-dependent. The relative order of attribute nodes is implementation-dependent.
\end{foreigndisplayquote}

Die Reihenfolge der Attribute eines Elements nach einem $\text{\acrshort{xml}}\rightarrow{}\text{\acrshort{json}}\rightarrow{}\text{\acrshort{xml}}$-Roundtrip ist daher beliebig und muss nicht mit der Reihenfolge vor der Umwandlung identisch sein.

\subsubsection{Whitespace}

Whitespace innerhalb des Wurzelelements des Dokumentens muss beibehalten werden, während 

\begin{foreigndisplayquote}{english}[{\cite[Abschnitt~2.1]{boyer2001c14n}}]
    All whitespace within the root document element MUST be preserved (except for any \texttt{\#xD} characters deleted by line delimiter normalization). This includes all whitespace in external entities. Whitespace outside of the root document element MUST be discarded.
\end{foreigndisplayquote}

\subsubsection{Mixed Content}

Eine Besonderheit von \acrshort{xml} und auch \acrshort{sgml} ist, dass die Spezifikation sogenannten \emph{Mixed Content} erlaubt. Dieser liegt vor, wenn ein Element sowohl Character Data als auch Kindelement enthält:

\begin{foreigndisplayquote}{english}[{\cite[Abschnitt 3.2.2]{maler2008xml}}]
    An element type has mixed content when elements of that type may contain character data, optionally interspersed with child elements.
\end{foreigndisplayquote}

\begin{example} Mixed Content
    \begin{minted}{xml}
<mixed>This is an element<br /> containing <emph>mixed content</emph>.<mixed>
    \end{minted}
\end{example}

\emph{Mixed Content} stellt \acrshort{xml}-Parser vor besondere Herausforderungen\cite{mcgrath2002mixedcontent}. Zudem existiert kein \acrshort{json}-Äquivalent von \emph{Mixed Content}, was eine Konversion erschwert.

\subsubsection{Typinferenz bei der Konversion zu JSON}

Zwar ist es möglich, mittels einer \acrfull{xsd} die in einem \acrshort{xml}-Dokument enthaltenten Datentypen genauer festzulegen, direkte syntaktische Unterstützung für Zahlen bietet \acrshort{xml} jedoch im Gegensatz zur \acrlong{json} nicht.

Wird kein Schema verwendet bzw. legt ein Schema den Datentyp eines Elements nicht anderweitig fest, so ist es standardmäßig vom Typ \texttt{xsd:anyType}:

\begin{foreigndisplayquote}{english}[{\cite[Abschnitt 2.2.1.1]{xmlschema11-1}}]
    A special complex type definition, (referred to in earlier versions of this specification as `the ur-type definition') whose name is \textbf{anyType} in the XSD namespace, is present in each ·\emph{XSD schema}·. The \textbf{definition of anyType} serves as default type definition for element declarations whose XML representation does not specify one.
\end{foreigndisplayquote}

Elemente dieses Typs unterliegen keinen Beschänkungen. Daher ist es ohne Zuhilfenahme eines Schemas nicht möglich, Aussagen über den Wertebereich eines Elements, eines Attributs oder einer Text Node zu treffen.

\begin{example} Type Inference
    \begin{minted}[linenos=false]{xml}
<price>5.99</price>
    \end{minted}
    \captionof{figure}{Dieses \acrshort{xml}-Dokument enthält einen numerischen Wert.}
    \label{fig:typeinferxml}

    \begin{minted}[linenos=false]{json}
{ "price": "5.99" }
    \end{minted}
    \captionof{figure}{\acrshort{json}-Entsprechung des \acrshort{xml}-Dokuments aus Abb.~\ref{fig:typeinferxml} \emph{ohne} Typinferenz enthält den Zahlenwert als String.}
    \label{fig:typeinferjson1}

    \begin{minted}[linenos=false]{json}
{ "price": 5.99 }
    \end{minted}
    \captionof{figure}{\acrshort{json}-Entsprechung des \acrshort{xml}-Dokuments aus Abb.~\ref{fig:typeinferxml} \emph{mit} Typinferenz enthält den Zahlenwert als \texttt{Number}.}
    \label{fig:typeinferjson2}

\end{example}

Ist das Schema eines \acrshort{xml}-Dokuments nicht bekannt, scheint es daher naheliegend, die Datentypen aus den im Dokument enthaltenen Werten abzuleiten. Enthält eine Text Node oder ein Attribut beispielsweise die Zeichenkette \mintinline{text}{123}, könnte daraus auf einen numerischer Datentyp geschlossen werden. Dieses Prinzip der \emph{Type Inference} nutzt beispielweise Microsoft im Rahmen des \emph{.NET Frameworks} um das \acrshort{xml}-Schema auf Basis von einem oder mehreren XML-Dokumenten zu \enquote{erraten}.\cite{msdn2017inferxmlschema}

Im Rahmen der \acrshort{xml} zu \acrshort{json}-Konversion ist es zwar wünschenswert, die nativen Datentypen der \acrshort{json}-Spezifikation voll auszunutzen, ein solches Vorgehen bringt jedoch mehrere Probleme mit sich:

\paragraph{Fehlerkennung von Typen}

Die oben beschriebene Vorgehensweise zur Typableitung kann zur Fehlerkennung von Datentypen führen.

Darf eine Text Node beispielsweise eigentlich beliebigen Zeicheninhalt enthalten, enthält aber \emph{zufälligerweise} ausschließlich Ziffern, würde fälschlicherweise ein Zahlentyp erkannt werden. Dies könnte zu Problemen mit der verarbeitetenden Applikation führen, die stattdessen eine Zeichenkette erwartet.

\paragraph{Einschränkungen durch Wertebereiche}

Ein weiteres Problem bei der \emph{Type Inference} kann durch die unterschiedlichen Wertebereichsgrenzen der verschiedenen Datentypen entstehen.  Während Zeichenketten in vielen Programmiersprachen mehrere tausend Zeichen lang sein dürfen, ist der Wertebereich von numerischen Datentypen in der Regel deutlich eingeschränkter. Wird ein Zahlenwert vom Konversionsprogramm also in einen nativen Datentyp umgewandelt, für den kleinerer Wertebereich gilt als durch Strings darstellbar sind, führt dies zu Fehlern oder Informationsverlust.

\begin{example} Informationsverlust durch Typumwandlung in JavaScript

    Die Programmiersprache \emph{JavaScript} erlaubt beispielsweise Strings mit einer Länge von bis zu $n=2^{53}-1 \approx 9 \cdot 10^{15}$ Zeichen, d.h. als Strings abgelegte Zahlen können rund 9 Billarden Stellen haben.\cite[Abschnitt 6.1.4]{ecma262} Für Zahlen im Dezimalsystem entspräche dies dem Wertebereich $\left\{x \in \mathbb{Z} \mid -\left(10^{n-1}-1\right) \leq x \leq 10^{n}-1\right\}$.

    Für den Datentyp \texttt{Number} nutzt JavaScript 64-bit-Fließkommazahlen nach dem IEEE-754-Standard (Doppelte Genauigkeit, \texttt{binary64}).\cite[Abschnitt 4.3.20]{ecma262}. Für Ganzzahlen gilt daher der \enquote{sichere} Wertebereich $\left\{x \in \mathbb{Z} \mid \abs{x} \leq 2^{53}-1\right\}$\cite[Abschnitt 20.1.2.5]{ecma262}. Dies entspricht einer Zahl mit lediglich $\floor{\log_{10}\left(2^{53}-1\right)}+1 = 16$ Ziffern im Dezimalsystem.

Zahlen außerhalb dieses Wertebereichs können nicht mehr fehlerfrei eingesetzt werden.

    \inputminted[firstline=2,firstnumber=1,mathescape]{javascript}{typeinference.js}
    \captionof{figure}{Die Umwandlung von numerischen Zeichenketten in den \texttt{Number}-Typ kann in JavaScript bei Zahlen $> 2^{53}-1$ zu Problemen führen.}
\end{example}

Ähnliches gilt für Konversionsverfahren, die aus Werten wie \mintinline{plain}{yes} und \mintinline{plain}{true} den Boole'schen Datentyp ableiten: Nach dem Konversion ist nicht mehr feststellbar, ob der Ursprungswert nun \mintinline{plain}{yes} oder \mintinline{plain}{true} lautete.

\section{XML-JSON-Konversionsverfahren}

\subsection{Json-lib}
\convtool[
    author={Andres Almiray (basierend auf Douglas Crockford)},
    url={http://json-lib.sourceforge.net/},
    license={Apache Software License 2.0},
    language=Java,
    version=2.4,
    versiondate=2010-12-14,
]{jsonlib}

\subsection{JsonML}
\convtool[
    author={Stephen M. McKamey},
    url={http://www.jsonml.org/},
    license=MIT,
    language=JavaScript,
    version=2.0.0,
    versiondate=2016-04-09,
]{jsonml}

\begin{definition}Formale Syntax der \acrfull{jsonml}
\label{def:jsonml}

Sowohl \synt{tag-name} als auch \synt{attribute-name} sind \acrshort{json}-Werte vom Typ String. Die Whitespace-Regeln sind identisch wie bei \acrshort{json} (Vgl. Definition~\ref{def:json}).

\begin{grammar}
    \input{grammar_jsonml.tex}
\end{grammar}
\end{definition}

\subsection{JXON}
\convtool[
    author={MDN / Martin Raifer},
    url={https://github.com/tyrasd/jxon},
    license=GNU General Public License 3.0,
    language=JavaScript,
    version=2.0.0-beta.4,
    versiondate=2016-11-22,
]{jxon}

\subsection{org.json.XML}
\convtool[
    author={JSON.org / Sean Leary},
    url={https://github.com/stleary/JSON-java},
    license=MIT,
    language=Java,
    version=20160810,
    versiondate=2016-08-10,
]{orgjsonxml}

\subsection{Pesterfish}
\convtool[
    author={Jacob Smullyan},
    url={https://bitbucket.org/smulloni/pesterfish/},
    license=MIT,
    language=Python,
    version=1578db9,
    versiondate=2010-11-22,
]{pesterfish}

\subsection{x2js}
\convtool[
    author={Axinom / Sander Saares (basierend auf Abdulla G. Abdurakhmanov)},
    url={https://github.com/x2js/x2js},
    license=Apache Software License 2.0,
    language=JavaScript,
    version=3.1.0,
    versiondate=2016-12-05,
]{x2js}

\subsection{xmljson}
\convtool[
    author={S Anand},
    url={https://github.com/sanand0/xmljson},
    license=MIT,
    language=Python,
    version=0.1.7,
    versiondate=2016-09-13,
]{xmljson}
