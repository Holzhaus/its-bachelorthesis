\chapter{Versuchsaufbau}
\label{chap:impl}

Im Folgenden wird wird der Versuchsaufbau, bestehend aus
\begin{enumerate}
    \item{} der Erstellung einer Reihe von Kriterien zur Bewertung der Verlustlosigkeit  und Sicherheit von Konversionverfahren,
    \item{} einer Auswahl von zu überprüfenden Konverter, und
    \item{} der Methodik zur Überprüfung der Konversionsverfahren auf Einhaltung der zuvor festgelegten Kriterien
\end{enumerate}
vorgestellt.

\section{Bewertungskriterien für Konversionsverfahren}
\label{sec:criteria}

Ziel ist die Suche nach einem Konversionsverfahren, dass sowohl \emph{sicher} als auch \emph{verlustlos} arbeitet. Dazu müssen beide Anforderungen zunächst genauer definiert werden.

\subsection{Sicherheit}

Die Sicherheit eines Konverters hängt in erster Linie von der Sicherheit des eingesetzten XML-Prozessors ab. Dieser darf gegen keinen der im Abschnitt~\ref{sec:xmlattacks} beschriebenen Angriffe auf XML-Parser verwundbar sein.

% TODO: Stuff still missing here

\subsection{Verlustlosigkeit}

Damit dieser Konversionsprozess als \emph{verlustlos} angesehen werden kann, müssen mehrere Bedingungen erfüllt sein:
\begin{enumerate}
    \item{} Eingabedokument und Ausgabedokument müssen logisch äquivalent sein.\label{item:ioequal}
    \item{} Sowohl das \acrshort{json}-Zwischenprodukt als auch das \acrshort{xml}-Ausgabedokument müssen gültige Dokumente sein.\label{item:outputwellf}
\end{enumerate}

Logisch äquivalent (vgl. Bed. \ref{item:ioequal}) heißt nicht, dass das \acrshort{xml}-Dokument nach dem Konversions-Round-Trip bitidentisch mit dem Ursprungsdokument sein muss -- es ist ausreichend, dass die Struktur der beiden Dokumente übereinstimmt. Daher werden beide Dokumente zunächst kanonisiert\footnote{Vgl. Abschnitt \ref{sec:c14n}} und im Anschluss verglichen. Stimmt die kanonische Form beider \acrshort{xml}-Dokumente überein, war die Konversion verlustlos.

\begin{figure}[h!]
\begin{definition}[Verlustlosigkeit von Konversion]
    Sei $V \coloneqq \{x \mid x\text{ ist ein valider }\allowbreak{}\text{\acrshort{json}-Wert}\}$ und $W \coloneqq \{x \mid x\text{ ist ein wohlgeformtes \acrshort{xml}-Dokument}\}$.

    Ein Konversionverfahren $K = (f_{enc}, f_{dec})$ mit $f_{enc}: W \mapsto V$ und $f_{dec}: V \mapsto W$ heißt \emph{verlustlos} genau dann wenn
    \begin{equation}
        (f_{dec}\mathrel{\circ} f_{enc})(x) \mathbin{\stackrel{c14n}{=}} x
    \end{equation}
    für alle $x \in W$.
\end{definition}
\end{figure}

% TODO: Add content here

\subsubsection{CDATA-Abschnitt}

Mithilfe von CDATA-Abschnitten lässt sich Text, der Markup-Zeichen wie beispielsweise das Kleiner-als-Zeichen\footnote{Unicode-Codepoint \texttt{U+003C}: \texttt{LESS-THAN SIGN}} enthält, direkt in ein XML-Dokument einbetten, ohne dass diese Zeichen als Markup interpretiert werden.

Dies ist vor allem dann sinnvoll, wenn es unpraktikabel ist, alle Markup-Zeichen im Text einzeln durch die jeweilige Zeichen- oder Entity-Referenz zu ersetzen. CDATA stellt somit eine weitere Möglichkeit dar, Zeichendaten in einem XML-Dokument anzugeben.~\cite[Abschnitt~2.4]{maler2008xml}

Der Unterschied zwischen Zeichendaten aus CDATA-Abschnitten und solchen, bei denen dies nicht der Fall ist, ist jedoch lediglich ein syntaktischer. Daher werden bei der \acrlong{c14n} alle CDATA-Abschnitte im Eingabedokument durch den entsprechenden \emph{Character Content} ersetzt~\cite[Abschnitt~2.1]{boyer2001c14n}.

Für die Verlustlosigkeit der Konversion ist es somit unerheblich, ob die CDATA-Abschnitte im Ursprungsdokument als solche erhalten bleiben, oder lediglich die Zeichendaten beibehalten werden.

\subsubsection{Kommentare}

\acrshort{xml} verfügt über die Möglichkeit, Dokumente mit Kommentaren zu versehen. Allerdings müssen diese nicht durch den XML-Prozessor zugänglich gemacht werden. In der Empfehlung des \gls{w3c} heißt es dazu:

\begin{foreigndisplayquote}{english}[{~\cite[Abschnitt~2.5]{maler2008xml}}]
They are not part of the document's character data; an XML processor may, but need not, make it possible for an application to retrieve the text of comments.
\end{foreigndisplayquote}

Zudem ist auch bei der Implementierung der \acrlong{c14n} die Unterstützung von \emph{Kanonischem XML mit Kommentaren} lediglich empfohlen, während die Möglichkeit der Umwandlung in \emph{Kanonisches XML} ausschließlich aller Kommentare zwingend erforderlich ist.~\cite[Abschnitt~2.1]{boyer2001c14n}

Folglich ist es nicht nötig, dass sich die Kommentare im XML-Eingabedokument nach dem $XML\rightarrow{}JSON\rightarrow{}XML$ Roundtrip auch in der Ausgabe wiederfinden.

\subsubsection{\acrfullpl{pi}}

Wie bereits \acrshort{sgml} unterstützt \acrshort{xml} die Einbettung von Anweisungen, die für die verarbeitetende Applikation bestimmt sind. Diese werden \acrfull{pi} genannt. 

In der Praxis werden \glspl{pi} eher selten eingesetzt. Genutzt werden sie unter anderem um Darstellungsinformationen in Form von Stylesheets mit \acrshort{xml}-Dokumenten zu verknüpfen.~\cite[Abschnitt 4]{xmlstylesheet}

Ein weiteres prominentes Beispiel für eine Praxisanwendung ist die Microsoft Office Suite, die seit der Version 2003 Office-Dokumente als einzelne XML-Datei speichern kann. Diese setzen die unspezifische Dateiendung \texttt{*.xml} ein und würden daher mit einem generisch XML-Anzeigeprogramm geöffnet werden. Mithilfe der Processing Instruction \mintinline{XML}{<?mso-application progid="Word.Document"?>} werden Windows- bzw. Internet Explorer angewiesen, diese als Microsoft Word-Document zu behandeln.~\cite[Abschnitt 3.2]{tverskov2008understandingpi}

Auch die XSLT-Stylesheets des DocBook-Formats nutzen Processing Instructions, um spezielle Formatierungen für die verschiedenen Ausgabeformate festzulegen.~\cite[{Kapitel \enquote{User Reference: PIs}}]{docbookxsl}

Die Unterstützung durch \acrshort{xml}-Parser ist von der Spezifikation zwingend vorgeschrieben.

\begin{foreigndisplayquote}{english}[{~\cite[Abschnitt~2.6]{maler2008xml}}]
\acrshortpl{pi} are not part of the document's character data, but \emph{must} be passed through to the application. 
\end{foreigndisplayquote}

Auch bei der \acrlong{c14n} bleiben die \glspl{pi} erhalten.~\cite[Abschnitt 2.3]{boyer2001c14n}

\subsubsection{Dokumentordnung}

\paragraph{Elementordnung}

Die Spezifikation der \acrshort{c14n} bezieht sich bezüglich der Ordnung auf die \acrshort{w3c}-Empfehlung zur \acrfull{xpath}~\cite[Abschnitt~2.2]{boyer2001c14n}.

\begin{foreigndisplayquote}{english}[{~\cite[Abschnitt~5]{clark1999xpath1}}]
There is an ordering, document order, defined on all the nodes in the document corresponding to the order in which the first character of the XML representation of each node occurs in the XML representation of the document after expansion of general entities. Thus, the root node will be the first node. Element nodes occur before their children. Thus, document order orders element nodes in order of the occurrence of their start-tag in the XML (after expansion of entities).
\end{foreigndisplayquote}

Folglich muss die Reihenfolge der Element-Nodes bei der Konversion beibehalten werden.

\paragraph{Ordnung von Attributen und Namespaces}

Laut dem \acrshort{xml}-Standard kommen der Reihenfolge, in der die Attribute eines Elements angegeben wurden, keine Bedeutung zu.

\begin{foreigndisplayquote}{english}[{~\cite[Abschnitt~3.1]{maler2008xml}}]
Note that the order of attribute specifications in a start-tag or empty-element tag is not significant.
\end{foreigndisplayquote}

Dies wird auch von der \acrshort{xpath}-Spezifikation untermauert:

\begin{foreigndisplayquote}{english}[{~\cite[Abschnitt~5]{clark1999xpath1}}]
The relative order of namespace nodes is implementation-dependent. The relative order of attribute nodes is implementation-dependent.
\end{foreigndisplayquote}

Die Reihenfolge der Attribute eines Elements nach einem $\text{\acrshort{xml}}\rightarrow{}\text{\acrshort{json}}\rightarrow{}\text{\acrshort{xml}}$-Roundtrip ist daher beliebig und muss nicht mit der Reihenfolge vor der Umwandlung identisch sein.

\subsubsection{Whitespace}

Whitespace innerhalb des Wurzelelements des Dokumentens muss beibehalten werden, während 

\begin{foreigndisplayquote}{english}[{~\cite[Abschnitt~2.1]{boyer2001c14n}}]
    All whitespace within the root document element MUST be preserved (except for any \texttt{\#xD} characters deleted by line delimiter normalization). This includes all whitespace in external entities. Whitespace outside of the root document element MUST be discarded.
\end{foreigndisplayquote}

\subsubsection{Mixed Content}

Eine Besonderheit von \acrshort{xml} und auch \acrshort{sgml} ist, dass die Spezifikation sogenannten \emph{Mixed Content} erlaubt. Dieser liegt vor, wenn ein Element sowohl Character Data als auch Kindelement enthält:

\begin{foreigndisplayquote}{english}[{~\cite[Abschnitt 3.2.2]{maler2008xml}}]
    An element type has mixed content when elements of that type may contain character data, optionally interspersed with child elements.
\end{foreigndisplayquote}

\begin{example} Mixed Content
    \begin{minted}{xml}
<mixed>This is an element<br /> containing <emph>mixed content</emph>.<mixed>
    \end{minted}
\end{example}

\emph{Mixed Content} stellt \acrshort{xml}-Parser vor besondere Herausforderungen~\cite{mcgrath2002mixedcontent}. Zudem existiert kein \acrshort{json}-Äquivalent von \emph{Mixed Content}, was eine Konversion erschwert.

\subsubsection{Typinferenz bei der Konversion zu JSON}

Zwar ist es möglich, mittels einer \acrfull{xsd} die in einem \acrshort{xml}-Dokument enthaltenten Datentypen genauer festzulegen, direkte syntaktische Unterstützung für Zahlen bietet \acrshort{xml} jedoch im Gegensatz zur \acrlong{json} nicht.

Wird kein Schema verwendet bzw. legt ein Schema den Datentyp eines Elements nicht anderweitig fest, so ist es standardmäßig vom Typ \texttt{xsd:anyType}:

\begin{foreigndisplayquote}{english}[{~\cite[Abschnitt 2.2.1.1]{xmlschema11-1}}]
    A special complex type definition, (referred to in earlier versions of this specification as `the ur-type definition') whose name is \textbf{anyType} in the XSD namespace, is present in each ·\emph{XSD schema}·. The \textbf{definition of anyType} serves as default type definition for element declarations whose XML representation does not specify one.
\end{foreigndisplayquote}

Elemente dieses Typs unterliegen keinen Beschänkungen. Daher ist es ohne Zuhilfenahme eines Schemas nicht möglich, Aussagen über den Wertebereich eines Elements, eines Attributs oder einer Text Node zu treffen.

\begin{example} Type Inference
    \begin{minted}[linenos=false]{xml}
<price>5.99</price>
    \end{minted}
    \captionof{figure}{Dieses \acrshort{xml}-Dokument enthält einen numerischen Wert.}
    \label{fig:typeinferxml}

    \begin{minted}[linenos=false]{json}
{ "price": "5.99" }
    \end{minted}
    \captionof{figure}{\acrshort{json}-Entsprechung des \acrshort{xml}-Dokuments aus Abb.~\ref{fig:typeinferxml} \emph{ohne} Typinferenz enthält den Zahlenwert als String.}
    \label{fig:typeinferjson1}

    \begin{minted}[linenos=false]{json}
{ "price": 5.99 }
    \end{minted}
    \captionof{figure}{\acrshort{json}-Entsprechung des \acrshort{xml}-Dokuments aus Abb.~\ref{fig:typeinferxml} \emph{mit} Typinferenz enthält den Zahlenwert als \texttt{Number}.}
    \label{fig:typeinferjson2}

\end{example}

Ist das Schema eines \acrshort{xml}-Dokuments nicht bekannt, scheint es daher naheliegend, die Datentypen aus den im Dokument enthaltenen Werten abzuleiten. Enthält eine Text Node oder ein Attribut beispielsweise die Zeichenkette \mintinline{text}{123}, könnte daraus auf einen numerischer Datentyp geschlossen werden. Dieses Prinzip der \emph{Type Inference} nutzt beispielweise Microsoft im Rahmen des \emph{.NET Frameworks} um das \acrshort{xml}-Schema auf Basis von einem oder mehreren XML-Dokumenten zu \enquote{erraten}.~\cite{msdn2017inferxmlschema}

Im Rahmen der \acrshort{xml} zu \acrshort{json}-Konversion ist es zwar wünschenswert, die nativen Datentypen der \acrshort{json}-Spezifikation voll auszunutzen, ein solches Vorgehen bringt jedoch mehrere Probleme mit sich:

\paragraph{Fehlerkennung von Typen}

Die oben beschriebene Vorgehensweise zur Typableitung kann zur Fehlerkennung von Datentypen führen.

Darf eine Text Node beispielsweise eigentlich beliebigen Zeicheninhalt enthalten, enthält aber \emph{zufälligerweise} ausschließlich Ziffern, würde fälschlicherweise ein Zahlentyp erkannt werden. Dies könnte zu Problemen mit der verarbeitetenden Applikation führen, die stattdessen eine Zeichenkette erwartet.

\paragraph{Einschränkungen durch Wertebereiche}

Ein weiteres Problem bei der \emph{Type Inference} kann durch die unterschiedlichen Wertebereichsgrenzen der verschiedenen Datentypen entstehen.  Während Zeichenketten in vielen Programmiersprachen mehrere tausend Zeichen lang sein dürfen, ist der Wertebereich von numerischen Datentypen in der Regel deutlich eingeschränkter. Wird ein Zahlenwert vom Konversionsprogramm also in einen nativen Datentyp umgewandelt, für den ein kleinerer Wertebereich gilt als durch Strings darstellbar sind, führt dies zu Fehlern oder Informationsverlust.

\begin{example} Informationsverlust durch Typumwandlung in JavaScript

    Die Programmiersprache \emph{JavaScript} erlaubt beispielsweise Strings mit einer Länge von bis zu $n=2^{53}-1 \approx 9 \cdot 10^{15}$ Zeichen, d.h. als Strings abgelegte Zahlen können rund 9 Billarden Stellen haben.~\cite[Abschnitt 6.1.4]{ecma262} Für Zahlen im Dezimalsystem entspräche dies dem Wertebereich $\left\{x \in \mathbb{Z} \mid -\left(10^{n-1}-1\right) \leq x \leq 10^{n}-1\right\}$.

    Für den Datentyp \texttt{Number} nutzt JavaScript 64-bit-Fließkommazahlen nach dem IEEE-754-Standard (Doppelte Genauigkeit, \texttt{binary64}).~\cite[Abschnitt 4.3.20]{ecma262}. Für Ganzzahlen gilt daher der \enquote{sichere} Wertebereich $\left\{x \in \mathbb{Z} \mid \abs{x} \leq 2^{53}-1\right\}$~\cite[Abschnitt 20.1.2.5]{ecma262}. Dies entspricht einer Zahl mit lediglich $\floor{\log_{10}\left(2^{53}-1\right)}+1 = 16$ Ziffern im Dezimalsystem.

Zahlen außerhalb dieses Wertebereichs können nicht mehr fehlerfrei eingesetzt werden.

    \inputminted[firstline=2,firstnumber=1,mathescape]{javascript}{typeinference.js}
    \captionof{figure}{Die Umwandlung von numerischen Zeichenketten in den \texttt{Number}-Typ kann in JavaScript bei Zahlen $> 2^{53}-1$ zu Problemen führen.}
\end{example}

Ähnliches gilt für Konversionsverfahren, die aus Werten wie \mintinline{text}{yes} und \mintinline{text}{true} den Boole'schen Datentyp ableiten: Nach dem Konversion ist nicht mehr feststellbar, ob der Ursprungswert nun \mintinline{text}{yes} oder \mintinline{text}{true} lautete.

\section{Auswahl der XML-JSON-Konverter}

\begin{figure}[hb!]
    \begin{threeparttable}
        \caption{Liste der überprüften Konverter}
        \begin{tabularx}{\textwidth}{p{2.65cm}Xp{1.6cm}p{1.5cm}p{2.1cm}}
            \rowcolor{white} % strange hack
            \toprule
            {\fontfamily{rubflama}\selectfont{}\bfseries Konverter} &
            {\fontfamily{rubflama}\selectfont{}\bfseries Autor} &
            {\fontfamily{rubflama}\selectfont{}\bfseries Lizenz} &
            {\fontfamily{rubflama}\selectfont{}\bfseries Sprache} &
            {\fontfamily{rubflama}\selectfont{}\bfseries Version}\\
            \midrule
            Cobra vs\newline Mongoose\tnote{a} & {Paul Battley} & MIT & Ruby & \texttt{0.0.2}\newline 27.06.2006\\
            \rowcolor{rubgray!80}
            GreenCape XML Converter\tnote{b} & {Niels Braczek} & MIT & PHP & \texttt{a830542}\newline 02.07.2015\\
        Json-lib\tnote{c} & {Andres Almiray\tnote{1}} & Apache~2.0 & Java & \texttt{2.4}\newline 14.12.2010\\
            \rowcolor{rubgray!80}
            \acrshort{jsonml}\tnote{d} & {Stephen M. McKamey} & MIT & JavaScript & \texttt{2.0.0}\newline 09.04.2016\\
            JXON\tnote{e} & {Martin Raifer, Mozilla} & GNU GPL~3.0 & JavaScript & \texttt{2.0.0-beta.4}\newline 22.11.2016\\
            \rowcolor{rubgray!80}
            org.json.XML\tnote{f} & {Sean Leary / JSON.org} & MIT & Java & \texttt{20160810}\newline 10.08.2016\\
            Pesterfish\tnote{g} & {Jacob Smullyan} & MIT & Python & \texttt{1578db9}\newline 22.11.2010\\
            \rowcolor{rubgray!80}
            x2js\tnote{h} & {Sander Saares / Axinom\tnote{2}} & Apache~2.0 & JavaScript & \texttt{3.1.0}\newline 05.12.2016\\
            xmljson\tnote{j} & {S. Anand} & MIT & Python & \texttt{0.1.7}\newline 09.05.2017\\
            \rowcolor{rubgray!80}
            \bottomrule
        \end{tabularx}
        {\footnotesize
        \begin{tablenotes}[para]
            \item[1] Basiert auf Software von Douglas Crockford.
            \item[2] Fork der \emph{x2js}-Bibliothek von Abdulla G. Abdurakhmanov.
            \item[a] \url{https://rubygems.org/gems/cobravsmongoose}
            \item[b] \url{https://github.com/GreenCape/xml-converter}
            \item[c] \url{http://json-lib.sourceforge.net/}
            \item[d] \url{http://www.jsonml.org/}
            \item[e] \url{https://github.com/tyrasd/jxon}
            \item[f] \url{https://github.com/stleary/JSON-java}
            \item[g] \url{https://bitbucket.org/smulloni/pesterfish/}
            \item[h] \url{https://github.com/x2js/x2js}
            \item[i] \url{https://github.com/sanand0/xmljson}
        \end{tablenotes}}
    \end{threeparttable}
\end{figure}

Inzwischen sind eine große Anzahl an Applikationen und Programmbiliotheken für die Umwandlung zwischen \acrshort{json} und \acrshort{xml} verfügbar. Dabei sind im Rahmen dieser Arbeit lediglich solche Konverter von Interesse, die
\begin{enumerate}
    \item{} XML-Dokumente zu JSON umwandeln können, und
    \item{} aus den so erhaltenen JSON-Strukuren wieder XML-Dokumente erstellen können.
\end{enumerate}

Die Auswahl beinhaltet eine Reihe von Konvertern, die in verschiedenen populären Programmiersprachen implementiert sind. 

\begin{description}
    \item[Cobra vs Mongoose] Diese Implementierung ist in Form eines Ruby-Gems verfügbar und übersetzt \acrshort{xml}-Dokumente in Ruby-Datenstrukturen (Hashes), kann aber auch JSON-Daten ausgeben. Bei der Umwandlung setzt die  Konverter auf die sogenannte \emph{Badgerfish}-Konvention.
    \item[GreenCape XML Converter] Der PHP XML Konverter kann XML-Daten in  assoziativen PHP-Arrays umwandeln. Diese können dann zu JSON-Werten serialisiert werden.
    \item[Json-lib] Die Java-Bibliothek \texttt{net.sf.json-lib} baut auf Software des JSON-Entwicklers Douglas Crockford auf und wird laut Maven-Repository über 400 anderen Projekten eingesetzt und beinhaltet unter Anderem auch eine Klasse zum (De-)Serialisieren von XML-Daten.
    \item[{\acrshort{jsonml}}] Die \acrfull{jsonml} ist JSON-basiertes Format zum Speicherung von XML-Markup. Neben der relativ populären\footnote{125 Sterne auf GitHub (Stand: \DTMdate{2017-06-14})} JavaScript-Bibliothek existieren auch Implementerungen in anderen Programmiersprache, z.B. in Java\footnote{Das \texttt{org.json}-Paket stellt eine entsprechende Klasse bereit.}  oder PHP\footnote{Als Teil des FluentDOM-Projekts, siehe: \url{https://github.com/FluentDOM/FluentDOM/blob/master/src/FluentDOM/Serializer/Json/JsonML.php}}.
    \item[{\acrshort{jxon}}] Bei dem JavaScript-Modul handelt es sich um eine birdirektionale Bibliothek für die \acrlong{jxon}. Es handelt sich um eine eine Weiterentwicklung der ursprünglich von Mozilla veröffentlichten Implementierung.
    \item[org.json.XML] Das Paket \texttt{org.json} ist die Referenzimplementierung des JSON-Format für Java und bietet auch eine Konversionsverfahren in Form einer dedizierten \acrshort{xml}-Klasse.
    \item[Pesterfish] Das Python-Modul Pesterfish konvertiert zwischen XML und Python-Dictionaries, die dann zu JSON serialisiert werden können. Laut dem Autor wurde das Konversionsverfahren als \enquote{Reaktion auf die Badgerfish-Konvention} entwickelt. Für die Verarbeitung der XML-Daten baut das Modul auf die \texttt{ElementTree}-\acrshort{api} auf und erlaubt Entwicklern auch die Angabe eines eigenen Parsers, beispielsweise \texttt{defusedxml}.
    \item[x2js] Bei der JavaScript-Modul handelt es um einen für die Verwendung mit NodeJS ausgelegten Fork des populären\footnote{467 Sterne auf GitHub (Stand: \DTMdate{2017-06-14})} xj2s-Bibliothek.
    \item[xmljson] Das Python-Paket \emph{xmljson} wurde mehr als 11\,500 mal vom Python-Repository PyPI heruntergeladen\footnote{11691 Downloads von PyPI (Stand: \DTMdate{2017-06-14})} und unterstützt die Konversion vom XML-Daten in Python-Dictionaries/Lists bzw. JSON anhand von 6 verschiedenen Konventionen.
\end{description}


\section{Methodik}
\label{sec:method}

\subsection{Überprüfung der Konversionqualität}
\label{sec:method-conv}

\begin{figure}[t]
    \begin{center}
        \includestandalone[width=0.8\textwidth]{flowchart_conversiontest}
        \caption{Ablauf der Konversionstests}
    \end{center}
\end{figure}

Zur Überprüfung der Konversionsqualität wurden für alle der in Abschnitt~\ref{sec:criteria} festgelegten Kriterien ein oder mehrere Testfälle erstellt. Jeder der Testfälle besteht aus einer \acrshort{xml}-Datei, anhand derer verschiedene XML-Features oder Problemstellungen nachvollzogen werden können. Die Dateien werden dazu zunächst mit einem Konverter in das \acrshort{json}-Format umgewandelt. Die daraus resultierenden \acrshort{json}-Daten werden im Anschluss wieder zurück in das \acrshort{xml}-Format konvertiert, d.h. es wird ein kompletter Round-Trip vollzogen.

Gemäß Definiton~\ref{def:lossless} gibt ein Abgleich zwischen den daraus resultierenden \acrshort{xml}-Daten und dem ursprünglichen XML-Dokument dann Aufschluss über den eventuellen Verlust signifikanter Informationen. Dazu wird wird überprüft, ob beide Dokumente logisch äquivalent sind, indem auf beide in \emph{kanonisches XML} umgewandelt. Ob Informationsverlust aufgetreten ist, kann dann mit simplen Vergleich geprüft werden.

Es muss zudem sichergestellt sein, dass bei der Konversion auch tatsächlich valides \acrshort{json} bzw. wohlgeformtes \acrshort{xml} zurückgegeben wird. Da das von Konverter zurückgelieferte Dokument im Zuge der \acrlong{c14n} geparst wird, werden Verstöße gegen die Wohlgeformtheitsanforderungen der \acrshort{xml}-Spezifikation erkannt und führen zum Nichtbestehen des Tests.

Die \acrshort{json}-Zwischendaten ebenfalls geparst und auf Verstöße gegen die JSON-Spezifikation untersucht. Zudem werden die Daten vor der Rückkonvertierung neu formatiert, sodass nur Informationen weitergegeben werden, die auch tatsächlich signifikant im Sinne der Spezifikation sind, d.h. dass beispielsweise Whitespace außerhalb von Zeichenketten oder die Reihenfolge von Wertpaaren innerhalb eines \acrshort{json}-Objekts verloren geht.

\begin{figure}[b!]
    \begin{center}
        \includestandalone[width=0.8\textwidth]{flowchart_securitytest}
        \caption{Ablauf der Sicherheitstests}
    \end{center}
\end{figure}

\subsection{Überprüfung der Sicherheit}
\label{sec:method-sec}

Um die Sicherheit der Konversion zu überprüfen, wird eine modifizierte Vorgehensweise genutzt. Die auf Sicherheitslücken in \acrshort{xml}-Parsern abzielenden Test-Dokumente werden ebenfalls zunachst in das JSON-Format und im Anschluss wieder zurück in XML konvertiert. Allerdings ist dabei ausschließlich von belang, dass keine der in Abschnitt~\ref{sec:xmlattacks} beschriebenen Angriffe ausgelöst wird -- die Korrektheit der Konversion ist hierbei nicht von Belang.

Stattdessen wird ein Sicherheitstest als Fehlschlag gewerten, wenn eine oder mehrere der folgenden Bedingungen zutrifft:
\begin{enumerate}
    \item[] Der Konversionsvorgang überschreitet zuvor festgelege Obergrenzen für die Allozierung von Arbeitsspeicher, verbraucht zuviel CPU-Zeit oder dauert zu lange.\label{itm:cond-dos}
    \item[] Während der Konversion sendet der Konverter Anfragen an einen Webserver.\label{itm:cond-ssrf}
    \item[] Die vom Konverter ausgegebenen \acrshort{json}- oder \acrshort{xml}-Dateien enthalten eine bestimmte Zeichenkette.\label{itm:cond-fsa}
\end{enumerate}

Ist der eingesetzte XML-Parser verwundbar gegenüber Angriffen aus dem Bereich \acrfull{dos}, führt das Parsen der Testdateien zu einem erhöhten Verbrauch an Systemressourcen. Die Obergrenzen für Arbeitsspeicherbelegung, CPU-Belastung und Zeitdauer sind so angelegt, dass ein erfolgreicher Angriff zwangsläufig gegen die erste Bedingung verstößt und damit zum Nichtbestehen des Tests führt.

Um zu Prüfen, ob \acrfull{ssrf} möglich ist, wird ein \acrshort{http}-Server gestartet, der von den entsprechenden Testfällen referenziert wird. Ruft ein Konverter während des Parsings eine der URLs auf, wird die Anfrage vom Server aufgezeichnet. Sind bei dem Server bis zum Abschluss der Konversion keine Anfragen eingegangen (Bed.~\ref{itm:cond-ssrf}), ist der Konverter offenbar nicht anfällig für solche Angriffe.

Die Testfälle für die Suche nach Schwachstellen der Kategorie \acrlong{fsa} verweisen auf Dateien, die eine bestimmte Zeichenkette enthalten. Ist diese Zeichenkette in den vom Konverter ausgegebenen \acrshort{json}- oder \acrshort{xml}-Daten enthalten, wurde vom Parser auf das Dateisystem zugegriffen und der Konverter ist verwundbar.

\subsection{Technische Umsetzung}

% SLOC calculated via:
%     git ls-files | tr '\n' '\0' | wc -l --files0-from=- | grep -E ".*py$" | awk '{print $1}' | paste -sd+ | bc

Zur einfacheren Durchführung der Testreihen wurde Evaluations-Framework auf Basis von Python 3.5 implementiert, das ca. 2200 SLOC umfasst. Der Testprozess wird dabei weitestgehend automatisiert.

Um die die \acrlong{c14n} durchzuführen, nutzt das Framework die~\mintinline{python}{write_c14n()}-Methode aus der \emph{lxml}-Bibliothek\footnote{http://lxml.de/}. Die Kanonisierung erfolgt nicht-exklusiv (vgl. Abschn.~\ref{sec:exc-c14n}) und ohne Kommentare -- ausgenommen ist dabei der Testfall, der die Unterstützung für Kommentare überprüft.

Für das \acrshort{xml}-Parsing selbst kommt \emph{defusedxml}\footnote{https://pypi.python.org/pypi/defusedxml} zu Einsatz, das die gängigen Python-APIs zum Parsen von \acrshort{xml}-Dokumenten einem Security-Hardening unterzieht und daher nicht anfällig gegenüber fast allen Angriffsvektoren ist.\cite[Abschn. 9.5]{spaeth2016sok}

Zur Prüfung und Formatierung der \acrshort{json}-Daten wird das Python-Modul \emph{demjson}\footnote{http://deron.meranda.us/python/demjson/} eingesetzt, das über ein umfangreiches Möglichkeiten zum Finden von Verstößen gegen die \acrshort{json} (einen sogenannten \emph{Linter}) verfügt. Zusätzlich zum \texttt{strict}-Modus wurden einige besondere Einstellungen vorgenommen: Byte-Order-Marks wurden in Übereinstimmung mit der \acrshort{json}-Spezifikation explizit verboten. Null-Bytes und andere von der Spezifikation nicht verbotene, aber möglicherweise Kompatibilitätsprobleme verursachende Zeichen wurden erlaubt, da es sich hierbei um korrektes \acrshort{json} handelt.

Für die Sicherheitstests wird ein eigener Prozess gestartet. Da als Host-System Linux zum Einsatz kommt, wurde die Begrenzung der Systemressourcen mithilfe des \texttt{setrlimit()}-Syscalls umgesetzt. Werden die so festgelegten Obergrenzen für die zur Verfügung stehende CPU-Zeit und Größe des adressierbaren Speichers des Prozesses überschritten, wird der Prozess vom Kernel durch das Signale \texttt{SIGXCPU} bzw. \texttt{SIGKILL} oder \texttt{SIGSEGV} beendet. Das Framework prüft nach Beendigung des Prozesses, ob der Exitcode auf die Terminierung durch ein Signal hinweist oder ob der Prozess normal beendet wurde.
